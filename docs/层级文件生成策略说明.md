# Cortex-Memory 层级文件生成策略说明

## 📋 用户关注的问题

### 1. 父子目录的层级文件生成关系

**问题**: 
- 子目录发生变化时，父目录能随之更新吗？
- 是否先确保叶子节点生成，再生成父节点？

**当前实现的回答**:

#### 当前策略 (独立生成)

**每个目录独立生成自己的 L0/L1**，不会自动传播：

```
cortex://session/test-session/
├── timeline/
│   ├── .abstract.md      # 基于 timeline/ 目录下的直接子文件生成
│   ├── .overview.md
│   ├── 2026-02/
│   │   ├── .abstract.md  # 基于 2026-02/ 目录下的直接子文件生成
│   │   ├── .overview.md
│   │   └── 25/
│   │       ├── .abstract.md  # 基于 25/ 目录下的 .md 文件生成
│   │       ├── .overview.md
│   │       ├── msg1.md
│   │       └── msg2.md
```

**关键特点**:

1. **不聚合子目录的 .abstract.md**
   - 父目录 `timeline/` 的 .abstract.md **不会**包含子目录 `2026-02/` 的抽象内容
   - 每个目录只聚合**当前目录下的直接文件**（`.md` / `.txt`）

2. **独立生成，无父子依赖**
   - 可以**任意顺序**生成（叶子先、父节点先都可以）
   - 子目录更新后，父目录**不会自动更新**

3. **优点**:
   - 简单、独立、并发友好
   - 避免复杂的依赖关系

4. **缺点**:
   - 缺少自下而上的信息聚合
   - 父目录的摘要不能反映子目录的内容变化

---

### 2. 与 OpenViking 的对比

#### OpenViking 的策略 (层次聚合)

OpenViking 采用不同的方法：

```python
# 伪代码示例
def generate_directory_layers(dir_path):
    # 1. 先生成所有子目录的 L0/L1
    for subdir in subdirectories:
        generate_directory_layers(subdir)
    
    # 2. 聚合当前目录的内容 + 子目录的 .abstract.md
    content = ""
    content += read_direct_files(dir_path)  # 当前目录的文件
    for subdir in subdirectories:
        content += read(subdir + "/.abstract.md")  # 子目录的摘要
    
    # 3. 生成当前目录的 L0/L1
    generate_abstract(content)
    generate_overview(content)
```

**特点**:
- ✅ 父目录的摘要包含子目录的信息
- ✅ 子目录变化会影响父目录
- ✅ 自下而上的信息传播
- ❌ 必须先生成叶子节点
- ❌ 实现复杂度较高

---

### 3. 我们的改进方案

#### 阶段 0: 独立生成 + 变更检测 (当前已实现) ✅

**核心改进**:

1. **避免重复生成**
   ```rust
   async fn should_regenerate(&self, uri: &str) -> Result<bool> {
       // 检查 .abstract.md 是否存在
       // 比较 .abstract.md 的时间戳与目录内文件的时间戳
       // 如果文件更新 → 需要重新生成
       // 如果文件未变 → 跳过生成（节省 token）
   }
   ```

2. **时间戳跟踪**
   - 每个 .abstract.md 包含 `**Added**: 2026-02-25 17:30:00 UTC`
   - 通过比较时间戳判断内容是否过期

3. **退出时生成**
   - cortex-mem-tars 在 `on_exit()` 时调用 `ensure_all_layers()`
   - 只生成缺失或过期的层级文件

#### 阶段 1: 层次聚合（未来计划）🔮

如果需要 OpenViking 式的自下而上聚合，可以这样实现：

```rust
// 🔮 未来改进（可选）
async fn aggregate_directory_content(&self, uri: &str) -> Result<String> {
    let entries = self.filesystem.list(uri).await?;
    let mut content = String::new();
    
    // 1. 读取当前目录的直接文件
    for entry in entries {
        if !entry.is_directory && entry.name.ends_with(".md") {
            let file_content = self.filesystem.read(&entry.uri).await?;
            content.push_str(&format!("\n\n=== {} ===\n\n", entry.name));
            content.push_str(&file_content);
        }
    }
    
    // 🆕 2. 读取子目录的 .abstract.md（可选功能）
    if self.config.aggregate_subdirectories {
        for entry in entries {
            if entry.is_directory {
                let subdir_abstract = format!("{}/.abstract.md", entry.uri);
                if let Ok(abstract_content) = self.filesystem.read(&subdir_abstract).await {
                    content.push_str(&format!("\n\n=== {} 摘要 ===\n\n", entry.name));
                    content.push_str(&abstract_content);
                }
            }
        }
    }
    
    Ok(content)
}
```

**启用方式**:
```rust
LayerGenerationConfig {
    aggregate_subdirectories: true,  // 🆕 新增配置项
    regenerate_parent_on_child_change: true,  // 🆕 子目录变化时重新生成父目录
    ...
}
```

---

## 🎯 当前实现总结

### 已实现功能 ✅

| 功能 | 状态 | 说明 |
|------|------|------|
| 退出时生成 L0/L1 | ✅ | `App::on_exit()` → `ensure_all_layers()` |
| 避免重复生成 | ✅ | 通过时间戳比较检测变更 |
| 批量延迟控制 | ✅ | `batch_size=10`, `delay_ms=1000` |
| 独立目录生成 | ✅ | 每个目录基于直接子文件生成 |

### 未实现功能 ⏭️

| 功能 | 优先级 | 说明 |
|------|--------|------|
| 层次聚合 | 低 | 父目录聚合子目录的 .abstract.md |
| 子目录变化触发父目录更新 | 低 | 需要依赖图管理 |
| 叶子优先生成顺序 | 低 | 目前是扫描顺序生成 |

---

## 💡 建议

### 对于 cortex-mem-tars 示例

**当前方案已足够**，原因：

1. **性能优先**: 独立生成更快，无复杂依赖
2. **token 节省**: 时间戳检测避免重复生成
3. **简单可靠**: 无需管理父子关系

### 如果需要层次聚合

**建议等到阶段1再实现**（目录递归检索），因为：

1. 需要与检索引擎的分数传播机制一起设计
2. 需要测试验证实际收益
3. 增加系统复杂度，需要谨慎评估

---

## 🔧 使用方式

### cortex-mem-tars 退出时生成

```rust
// examples/cortex-mem-tars/src/app.rs
pub async fn on_exit(&mut self) -> Result<()> {
    // 1. 关闭会话（生成 timeline/ 的 L0/L1）
    session_manager.write().await.close_session(session_id).await?;
    
    // 2. 生成所有缺失的 L0/L1（包括子目录）
    tenant_ops.ensure_all_layers().await?;
    //           ^^^^^^^^^^^^^^^^
    //           只生成缺失或过期的文件
    //           避免重复消耗 token
    
    Ok(())
}
```

### 手动触发生成

```bash
# CLI 工具
cargo run -p cortex-mem-cli -- layers ensure-all

# 查看状态
cargo run -p cortex-mem-cli -- layers status
```

---

## 📊 性能影响

### token 消耗对比

假设有 100 个目录：

| 场景 | 当前方案 | 无变更检测 |
|------|---------|-----------|
| 首次生成 | 100 次 LLM 调用 | 100 次 LLM 调用 |
| 第二次退出 | 0 次（无变更） | 100 次（重复生成）|
| 部分更新（10个） | 10 次 | 100 次 |

**节省比例**: ~90% token（当内容未变时）

---

## 🚀 总结

### 回答用户的问题

1. **子目录变化时，父目录能随之更新吗？**
   - **当前**: ❌ 不会自动更新
   - **原因**: 独立生成策略，父目录不聚合子目录的摘要
   - **未来**: 可以通过配置项启用层次聚合（阶段1）

2. **是否先生成叶子节点，再生成父节点？**
   - **当前**: ❌ 不保证顺序
   - **原因**: 独立生成，无依赖关系
   - **扫描顺序**: 取决于文件系统的遍历顺序
   - **未来**: 如果启用层次聚合，需要先生成叶子节点

3. **避免重复生成？**
   - **当前**: ✅ 已实现
   - **机制**: 时间戳比较，只生成变更的目录

---

**结论**: 当前的独立生成 + 变更检测方案已经满足 cortex-mem-tars 的需求，无需立即实现层次聚合功能。
