# 系统边界接口文档

本文档描述了系统的外部调用接口，包括CLI命令、API端点、配置参数等边界机制。

## 命令行接口 (CLI)

### cortex-mem-cli

**描述**: Rust Agent Memory System CLI，用于管理智能Agent的记忆数据

**源文件**: `cortex-mem-cli/src/main.rs`

**参数**:

- `command` (string): 必需 - 具体的子命令，包括Add、Search、List、Delete、Optimize、OptimizeStatus、OptimizeConfig
- `config` (string): 可选 - 配置文件路径，默认为config.toml (默认: `config.toml`)

**选项**:

- `content`(string): 必需 - 要存储为记忆的内容
- `user_id`(string): 可选 - 记忆的用户ID
- `agent_id`(string): 可选 - 记忆的代理ID
- `memory_type`(string): 可选 - 记忆类型（conversational, procedural, factual），默认为conversational (默认: `conversational`)
- `query`(string): 可选 - 搜索查询（可选，若不提供则仅使用元数据过滤）
- `topics`(array): 可选 - 主题过滤（逗号分隔）
- `keywords`(array): 可选 - 关键词过滤（逗号分隔）
- `limit`(integer): 可选 - 返回结果的最大数量，默认为10（Search）或20（List）
- `id`(string): 必需 - 要删除的记忆ID

**使用示例**:

```bash
cortex-mem-cli --config config.toml add --content "今天天气真好" --user_id "user123" --agent_id "agent456"
```

```bash
cortex-mem-cli --config config.toml search --query "如何做咖啡" --user_id "user123" --limit 5
```

```bash
cortex-mem-cli --config config.toml list --user_id "user123" --memory_type conversational
```

```bash
cortex-mem-cli --config config.toml delete --id "a1b2c3d4-e5f6-7890-g1h2-i3j4k5l6m7n8"
```

```bash
cortex-mem-cli --config config.toml optimize --config-file "optimize-config.toml"
```

### cortex-mem-mcp

**描述**: MCP服务器，用于通过标准输入输出（stdio）与外部系统通信，提供内存管理服务

**源文件**: `cortex-mem-mcp/src/main.rs`

**参数**:

- `config` (string): 可选 - 配置文件路径，默认为config.toml (默认: `config.toml`)

**使用示例**:

```bash
cortex-mem-mcp --config config.toml
```

### multi-round-interactive

**描述**: 多轮交互式对话TUI应用，提供基于终端的用户界面与记忆增强AI代理进行交互

**源文件**: `examples/cortex-mem-tars/src/main.rs`

**参数**:

- `config` (string): 可选 - 配置文件路径，默认为config.toml (默认: `config.toml`)

**使用示例**:

```bash
multi-round-interactive --config config.toml
```

### cortex-mem-service

**描述**: HTTP服务，提供RESTful API接口供外部系统调用

**源文件**: `cortex-mem-service/src/main.rs`

**参数**:

- `config` (string): 可选 - 配置文件路径，默认为config.toml (默认: `config.toml`)

**使用示例**:

```bash
cortex-mem-service --config config.toml
```

## API接口

### GET /health

**描述**: 检查服务健康状态，返回vector_store和LLM服务的健康状况

**源文件**: `cortex-mem-service/src/handlers.rs`

**响应格式**: {"status":"healthy|unhealthy","vector_store":true|false,"llm_service":true|false,"timestamp":"RFC3339时间戳"}

### POST /memories

**描述**: 创建新的记忆条目，支持普通文本内容或对话格式（User:/Assistant:）

**源文件**: `cortex-mem-service/src/handlers.rs`

**请求格式**: {"content":"字符串内容","user_id":"可选字符串","agent_id":"可选字符串","run_id":"可选字符串","actor_id":"可选字符串","role":"可选字符串","memory_type":"可选字符串，默认为conversational","custom":{}}

**响应格式**: {"message":"成功消息","id":"创建成功的记忆ID"}

### GET /memories

**描述**: 列出符合过滤条件的记忆条目，支持分页和多维度筛选

**源文件**: `cortex-mem-service/src/handlers.rs`

**响应格式**: {"total":整数,"memories":[{"id":"字符串","content":"字符串","metadata":{"user_id":"字符串","agent_id":"字符串","run_id":"字符串","actor_id":"字符串","role":"字符串","memory_type":"字符串","hash":"字符串","custom":{}},"created_at":"RFC3339时间戳","updated_at":"RFC3339时间戳"}] }

### POST /memories/search

**描述**: 基于查询语句和过滤器搜索相似记忆，支持相似度阈值控制

**源文件**: `cortex-mem-service/src/handlers.rs`

**请求格式**: {"query":"搜索查询字符串","user_id":"可选字符串","agent_id":"可选字符串","run_id":"可选字符串","actor_id":"可选字符串","memory_type":"可选字符串","limit":整数,"similarity_threshold":可选浮点数}

**响应格式**: {"total":整数,"results":[{"memory":{"id":"字符串","content":"字符串","metadata":{"user_id":"字符串","agent_id":"字符串","run_id":"字符串","actor_id":"字符串","role":"字符串","memory_type":"字符串","hash":"字符串","custom":{}},"created_at":"RFC3339时间戳","updated_at":"RFC3339时间戳"},"score":浮点数}] }

### GET /memories/:id

**描述**: 根据记忆ID获取单个记忆条目详情

**源文件**: `cortex-mem-service/src/handlers.rs`

**响应格式**: {"id":"字符串","content":"字符串","metadata":{"user_id":"字符串","agent_id":"字符串","run_id":"字符串","actor_id":"字符串","role":"字符串","memory_type":"字符串","hash":"字符串","custom":{}},"created_at":"RFC3339时间戳","updated_at":"RFC3339时间戳"}

### PUT /memories/:id

**描述**: 根据记忆ID更新记忆内容

**源文件**: `cortex-mem-service/src/handlers.rs`

**请求格式**: {"content":"新的记忆内容"}

**响应格式**: {"message":"成功消息","id":"更新的记忆ID"}

### DELETE /memories/:id

**描述**: 根据记忆ID删除记忆

**源文件**: `cortex-mem-service/src/handlers.rs`

**响应格式**: {"message":"成功消息","id":"删除的记忆ID"}

## 集成建议

### CLI

通过CLI工具进行本地调试和管理，适合开发和运维人员

**示例代码**:

```
# 添加一条记忆
cortex-mem-cli add --content "用户喜欢喝咖啡" --user_id "alice" --agent_id "coffee_bot"

# 搜索相关记忆
search --query "喜欢喝什么" --user_id "alice" --limit 3

# 查看所有记忆
list --user_id "alice" --memory_type conversational
```

**最佳实践**:

- 使用--config参数指定非默认配置文件以适应不同环境
- 在自动化脚本中结合jq解析JSON输出
- 将CLI命令封装为Shell别名或脚本以提高效率
- 避免在生产环境中直接暴露CLI，应通过API调用

### HTTP API

通过RESTful API集成到Web服务、微服务或AI代理系统中，是主要的生产集成方式

**示例代码**:

```
import requests

# 创建记忆
response = requests.post("http://localhost:8080/memories", json={
    "content": "用户在2023年购买了iPhone 15",
    "user_id": "user_001",
    "agent_id": "shopping_assistant",
    "memory_type": "factual"
})
print(response.json())

# 搜索记忆
response = requests.post("http://localhost:8080/memories/search", json={
    "query": "用户买了什么手机",
    "user_id": "user_001",
    "limit": 5
})
print(response.json())
```

**最佳实践**:

- 所有API调用应使用HTTPS协议
- 在生产环境中启用认证（如JWT或API Key）
- 对输入内容进行严格校验，防止注入攻击
- 使用连接池和重试机制处理LLM服务的高延迟
- 设置合理的超时和限流策略

### MCP

通过MCP（Memory Control Protocol）协议与外部AI代理框架（如RIG）集成，适用于需要低延迟、高可靠性的系统间通信

**示例代码**:

```
# 伪代码：在RIG代理中使用cortex-mem-mcp
from rmcp.transport import stdio
from cortex_mem_mcp import MemoryMcpService

service = MemoryMcpService.with_config_path("config.toml")
running_service = service.serve(stdio()).await
running_service.waiting().await
```

**最佳实践**:

- 确保MCP服务运行在隔离的容器或进程中
- 使用标准输入输出（stdio）进行通信，避免网络开销
- 为MCP服务配置独立的配置文件和日志目录
- 监控MCP服务的CPU和内存使用情况，避免影响主代理性能

### Configuration

通过配置文件统一管理所有模块参数，实现环境隔离和灵活部署

**示例代码**:

```
# config.toml 示例
[qdrant]
url = "http://localhost:6333"
collection_name = "cortex_mem_collection"
embedding_dim = 1536

c[llm]
api_base_url = "https://api.openai.com/v1"
api_key = "sk-..."
model_efficient = "gpt-3.5-turbo"
temperature = 0.3
max_tokens = 512

[memory]
auto_enhance = true
deduplicate = true
similarity_threshold = 0.65
search_similarity_threshold = 0.70

[server]
host = "0.0.0.0"
port = 8080
```

**最佳实践**:

- 使用环境变量注入敏感配置（如API密钥）
- 为不同环境（dev/staging/prod）维护独立的配置文件
- 定期备份配置文件并纳入版本控制
- 使用配置验证工具在启动时检查配置有效性

### External LLM

与OpenAI等外部LLM服务集成，用于记忆的语义分析和元数据增强

**示例代码**:

```
# 在cortex-mem-core/src/llm/client.rs中配置OpenAI
llm_config = LLMConfig {
    api_base_url: "https://api.openai.com/v1".to_string(),
    api_key: env!("OPENAI_API_KEY").to_string(),
    model_efficient: "gpt-4-turbo".to_string(),
    temperature: 0.2,
    max_tokens: 1000,
};
```

**最佳实践**:

- 使用环境变量而非硬编码API密钥
- 为不同LLM提供商实现适配器接口以支持多供应商
- 监控LLM调用成本和速率限制
- 实现本地缓存和失败降级机制以提高系统鲁棒性

### Vector Store

与Qdrant向量数据库集成，用于高效存储和检索记忆的向量表示

**示例代码**:

```
# 配置Qdrant连接
qdrant_config = QdrantConfig {
    url: "http://localhost:6333".to_string(),
    collection_name: "cortex_mem_collection".to_string(),
    embedding_dim: Some(1536),
    timeout_secs: 10,
};
```

**最佳实践**:

- 确保Qdrant实例与cortex-mem服务网络互通
- 为向量集合配置合适的索引类型（如HNSW）
- 定期监控Qdrant的磁盘使用率和查询延迟
- 为Qdrant启用TLS加密和访问控制

### TUI

使用TUI（文本用户界面）进行交互式调试和演示，适合演示和本地开发

**示例代码**:

```
# 启动TUI应用
multi-round-interactive --config config.toml

# 在TUI中输入：
> 你好，你能记住我之前说过的话吗？
> /quit
```

**最佳实践**:

- TUI仅用于开发和演示，不应在生产环境部署
- 使用crossterm和ratatui库确保跨平台兼容性
- 实现优雅退出机制，确保后台记忆存储任务完成


---

**分析置信度**: 9.8/10
