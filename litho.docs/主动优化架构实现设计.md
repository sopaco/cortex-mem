# Cortex-Memä¸»åŠ¨ä¼˜åŒ–æ¶æ„å®ç°è®¾è®¡

**ç”Ÿæˆæ—¶é—´**: 2025-12-05  
**ç‰ˆæœ¬**: v1.0  
**é¡¹ç›®**: cortex-mem å…¨æ ˆæ™ºèƒ½è®°å¿†ç®¡ç†ç³»ç»Ÿ  

---

## 1. æ¶æ„æ€»è§ˆ

### 1.1 è®¾è®¡åŸåˆ™

- **æ ¸å¿ƒèƒ½åŠ›å°è£…**: å°†ä¸»åŠ¨ä¼˜åŒ–æ ¸å¿ƒèƒ½åŠ›å°è£…åœ¨ `cortex-mem-core` ä¸­
- **ç»Ÿä¸€è§¦å‘æ¥å£**: é€šè¿‡ `memo-cli` å’Œ `memo-service` æä¾›ç»Ÿä¸€çš„è§¦å‘å…¥å£
- **å¯é…ç½®åŒ–**: æ”¯æŒé€šè¿‡é…ç½®æ–‡ä»¶çµæ´»æ§åˆ¶ä¼˜åŒ–è¡Œä¸º
- **æ¨¡å—åŒ–è®¾è®¡**: å„ä¼˜åŒ–ç»„ä»¶ç‹¬ç«‹ï¼Œä¾¿äºæµ‹è¯•å’Œç»´æŠ¤
- **å¼‚æ­¥éé˜»å¡**: æ‰€æœ‰ä¼˜åŒ–æ“ä½œå¼‚æ­¥æ‰§è¡Œï¼Œä¸å½±å“æ­£å¸¸æœåŠ¡

### 1.2 æ•´ä½“æ¶æ„

```mermaid
graph TB
    subgraph "cortex-mem-core"
        subgraph "memoryä¼˜åŒ–æ¨¡å—"
            MM[MemoryManager]
            MO[MemoryOptimizer]
            OD[OptimizationDetector]
            OCA[OptimizationAnalyzer]
            OEE[ExecutionEngine]
            ORR[ResultReporter]
        end
        
        subgraph "ä¼˜åŒ–ç­–ç•¥æ¨¡å—"
            OS[OptimizationStrategy]
            DS[DeduplicationStrategy]
            RS[RelevanceStrategy] 
            QOS[QualityStrategy]
            SAS[SpaceStrategy]
        end
        
        subgraph "è§¦å‘æœºåˆ¶æ¨¡å—"
            TM[TriggerManager]
            SC[Scheduler]
            MC[ManualController]
        end
    end
    
    subgraph "memo-cli"
        CO[OptimizeCommand]
        CP[CommandParser]
        CU[CommandUtil]
    end
    
    subgraph "memo-service"
        HH[HttpHandlers]
        AR[ApiRouter]
        RS[RequestSerializer]
    end
    
    subgraph "è§¦å‘æº"
        USER[ç”¨æˆ·æ“ä½œ]
        CRON[å®šæ—¶ä»»åŠ¡]
        API[APIè°ƒç”¨]
        MONITOR[ç›‘æ§å‘Šè­¦]
    end
    
    USER --> CO
    CRON --> CO
    MONITOR --> CO
    
    API --> HH
    HH --> AR
    AR --> RS
    
    CO --> TM
    HH --> TM
    TM --> MO
    MO --> MM
    MO --> OS
    MO --> OD
    MO --> OCA
    MO --> OEE
    MO --> ORR
```

---

## 2. cortex-mem-core æ ¸å¿ƒå®ç°

### 2.1 ç›®å½•ç»“æ„

```
cortex-mem-core/src/
â”œâ”€â”€ memory/
â”‚   â”œâ”€â”€ mod.rs                 # å¯¼å‡ºä¼˜åŒ–ç›¸å…³æ¨¡å—
â”‚   â”œâ”€â”€ optimizer.rs           # MemoryOptimizer æ ¸å¿ƒå®ç°
â”‚   â”œâ”€â”€ optimization_detector.rs  # é—®é¢˜æ£€æµ‹å™¨
â”‚   â”œâ”€â”€ optimization_analyzer.rs  # ä¼˜åŒ–åˆ†æå™¨
â”‚   â”œâ”€â”€ execution_engine.rs    # æ‰§è¡Œå¼•æ“
â”‚   â”œâ”€â”€ result_reporter.rs     # ç»“æœæŠ¥å‘Šå™¨
â”‚   â””â”€â”€ strategies/            # ä¼˜åŒ–ç­–ç•¥
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ deduplication.rs   # å»é‡ç­–ç•¥
â”‚       â”œâ”€â”€ relevance.rs       # ç›¸å…³æ€§ç­–ç•¥
â”‚       â”œâ”€â”€ quality.rs         # è´¨é‡ç­–ç•¥
â”‚       â””â”€â”€ space.rs           # ç©ºé—´ç­–ç•¥
â”œâ”€â”€ optimization/
â”‚   â”œâ”€â”€ mod.rs                 # ä¼˜åŒ–æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ config.rs              # ä¼˜åŒ–é…ç½®
â”‚   â”œâ”€â”€ triggers.rs            # è§¦å‘ç®¡ç†
â”‚   â”œâ”€â”€ scheduler.rs           # å®šæ—¶è°ƒåº¦
â”‚   â””â”€â”€ manual.rs              # æ‰‹åŠ¨æ§åˆ¶
â””â”€â”€ types/
    â””â”€â”€ optimization.rs        # ä¼˜åŒ–ç›¸å…³ç±»å‹å®šä¹‰
```

### 2.2 æ ¸å¿ƒæ¥å£è®¾è®¡

#### 2.2.1 MemoryOptimizer æ ¸å¿ƒæ¥å£

```rust
/// ä¸»åŠ¨å†…å­˜ä¼˜åŒ–å™¨ - æ ¸å¿ƒåè°ƒç»„ä»¶
#[async_trait]
pub trait MemoryOptimizer: Send + Sync {
    /// æ‰§è¡Œä¼˜åŒ–æ“ä½œ
    async fn optimize(&self, request: &OptimizationRequest) -> Result<OptimizationResult>;
    
    /// åˆ›å»ºä¼˜åŒ–è®¡åˆ’ï¼ˆé¢„è§ˆæ¨¡å¼ï¼‰
    async fn create_optimization_plan(&self, strategy: OptimizationStrategy) -> Result<OptimizationPlan>;
    
    /// è·å–ä¼˜åŒ–çŠ¶æ€
    async fn get_optimization_status(&self) -> Result<OptimizationStatus>;
    
    /// å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„ä¼˜åŒ–
    async fn cancel_optimization(&self, optimization_id: &str) -> Result<()>;
}

/// MemoryOptimizer å®ç°
pub struct DefaultMemoryOptimizer {
    memory_manager: Arc<MemoryManager>,
    config: OptimizationConfig,
    detector: Arc<OptimizationDetector>,
    analyzer: Arc<OptimizationAnalyzer>,
    executor: Arc<ExecutionEngine>,
    reporter: Arc<ResultReporter>,
}

#[async_trait]
impl MemoryOptimizer for DefaultMemoryOptimizer {
    async fn optimize(&self, request: &OptimizationRequest) -> Result<OptimizationResult> {
        let optimization_id = Uuid::new_v4().to_string();
        
        // 1. æ£€æµ‹é—®é¢˜
        tracing::info!("å¼€å§‹æ£€æµ‹å†…å­˜ä¼˜åŒ–é—®é¢˜");
        let issues = self.detector.detect_issues(&request.filters).await?;
        
        // 2. åˆ†æåˆ¶å®šè®¡åˆ’
        tracing::info!("åˆ¶å®šä¼˜åŒ–è®¡åˆ’");
        let plan = self.analyzer.create_optimization_plan(&issues, &request.strategy, &request.filters).await?;
        
        // 3. æ‰§è¡Œä¼˜åŒ–
        tracing::info!("æ‰§è¡Œä¼˜åŒ–è®¡åˆ’");
        let result = self.executor.execute_plan(&optimization_id, plan).await?;
        
        // 4. æŠ¥å‘Šç»“æœ
        self.reporter.report_optimization_result(&result).await?;
        
        Ok(result)
    }
    
    async fn create_optimization_plan(&self, strategy: OptimizationStrategy) -> Result<OptimizationPlan> {
        let issues = self.detector.detect_issues(&Default::default()).await?;
        self.analyzer.create_optimization_plan(&issues, &strategy, &Default::default()).await
    }
    
    async fn get_optimization_status(&self) -> Result<OptimizationStatus> {
        // è·å–å½“å‰ä¼˜åŒ–çŠ¶æ€
        todo!()
    }
    
    async fn cancel_optimization(&self, optimization_id: &str) -> Result<()> {
        // å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„ä¼˜åŒ–
        todo!()
    }
}
```

#### 2.2.2 è§¦å‘ç®¡ç†æ¥å£

```rust
/// ä¼˜åŒ–è§¦å‘ç®¡ç†å™¨
#[async_trait]
pub trait TriggerManager: Send + Sync {
    /// æ³¨å†Œè§¦å‘å™¨
    async fn register_trigger(&self, trigger: Box<dyn OptimizationTrigger>) -> Result<TriggerId>;
    
    /// å–æ¶ˆè§¦å‘å™¨
    async fn unregister_trigger(&self, trigger_id: &TriggerId) -> Result<()>;
    
    /// æ‰‹åŠ¨è§¦å‘ä¼˜åŒ–
    async fn trigger_optimization(&self, request: &OptimizationRequest) -> Result<String>;
    
    /// è·å–è§¦å‘å™¨çŠ¶æ€
    async fn get_trigger_status(&self) -> Result<Vec<TriggerStatus>>;
}

/// ä¼˜åŒ–è§¦å‘å™¨trait
#[async_trait]
pub trait OptimizationTrigger: Send + Sync {
    /// è§¦å‘å™¨åç§°
    fn name(&self) -> &str;
    
    /// è§¦å‘å™¨æè¿°
    fn description(&self) -> &str;
    
    /// æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘ä¼˜åŒ–
    async fn should_trigger(&self, optimizer: &dyn MemoryOptimizer) -> Result<bool>;
    
    /// è§¦å‘æ—¶æ‰§è¡Œçš„ä¼˜åŒ–è¯·æ±‚
    fn get_optimization_request(&self) -> OptimizationRequest;
}

/// å®šæ—¶è§¦å‘å™¨å®ç°
pub struct ScheduleTrigger {
    name: String,
    description: String,
    schedule: Schedule,
    strategy: OptimizationStrategy,
    filters: OptimizationFilters,
}

/// æ‰‹åŠ¨è§¦å‘å™¨å®ç°
pub struct ManualTrigger {
    name: String,
    request: OptimizationRequest,
}

/// ç›‘æ§è§¦å‘å™¨å®ç°ï¼ˆåŸºäºç³»ç»ŸæŒ‡æ ‡ï¼‰
pub struct MonitoringTrigger {
    name: String,
    description: String,
    thresholds: TriggerThresholds,
    strategy: OptimizationStrategy,
}
```

### 2.3 æ ¸å¿ƒç±»å‹å®šä¹‰

#### 2.3.1 ä¼˜åŒ–è¯·æ±‚å’Œç»“æœ

```rust
/// ä¼˜åŒ–è¯·æ±‚
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationRequest {
    pub optimization_id: Option<String>,
    pub strategy: OptimizationStrategy,
    pub filters: OptimizationFilters,
    pub aggressive: bool,
    pub dry_run: bool,
    pub timeout_minutes: Option<u64>,
}

/// ä¼˜åŒ–ç­–ç•¥
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OptimizationStrategy {
    /// å…¨é¢ä¼˜åŒ–
    Full,
    /// å¢é‡ä¼˜åŒ–
    Incremental,
    /// æ‰¹é‡ä¼˜åŒ–
    Batch,
    /// ä»…å»é‡
    Deduplication,
    /// ä»…ç›¸å…³æ€§ä¼˜åŒ–
    Relevance,
    /// ä»…è´¨é‡ä¼˜åŒ–
    Quality,
    /// ä»…ç©ºé—´ä¼˜åŒ–
    Space,
}

/// ä¼˜åŒ–è¿‡æ»¤å™¨
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationFilters {
    pub user_id: Option<String>,
    pub agent_id: Option<String>,
    pub memory_type: Option<MemoryType>,
    pub date_range: Option<DateRange>,
    pub importance_range: Option<Range<f32>>,
    pub custom_filters: HashMap<String, Value>,
}

/// ä¼˜åŒ–ç»“æœ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationResult {
    pub optimization_id: String,
    pub strategy: OptimizationStrategy,
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub issues_found: Vec<OptimizationIssue>,
    pub actions_performed: Vec<OptimizationAction>,
    pub metrics: OptimizationMetrics,
    pub success: bool,
    pub error_message: Option<String>,
}

/// ä¼˜åŒ–æ“ä½œ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OptimizationAction {
    Merge { memories: Vec<String> },
    Delete { memory_id: String },
    Update { memory_id: String, updates: MemoryUpdates },
    Reclassify { memory_id: String },
    Archive { memory_id: String },
}
```

#### 2.3.2 ä¼˜åŒ–é…ç½®

```rust
/// ä¼˜åŒ–é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationConfig {
    pub auto_optimize: bool,
    pub trigger_config: TriggerConfig,
    pub strategy_configs: StrategyConfigs,
    pub execution_config: ExecutionConfig,
    pub safety_config: SafetyConfig,
}

/// è§¦å‘å™¨é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TriggerConfig {
    pub auto_triggers: Vec<AutoTriggerConfig>,
    pub schedule_config: ScheduleConfig,
    pub manual_config: ManualConfig,
}

/// è‡ªåŠ¨è§¦å‘é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AutoTriggerConfig {
    pub name: String,
    pub enabled: bool,
    pub strategy: OptimizationStrategy,
    pub thresholds: TriggerThresholds,
    pub filters: Option<OptimizationFilters>,
}

/// æ‰§è¡Œé…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionConfig {
    pub batch_size: usize,
    pub max_concurrent_tasks: usize,
    pub timeout_minutes: u64,
    pub retry_attempts: u32,
    pub progress_callback: Option<ProgressCallback>,
}
```

---

## 3. memo-cli é›†æˆå®ç°

### 3.1 å‘½ä»¤è®¾è®¡

#### 3.1.1 å‘½ä»¤ç»“æ„

```rust
/// ä¼˜åŒ–ç›¸å…³å‘½ä»¤
pub mod optimize {
    use clap::Parser;
    use crate::types::*;
    
    #[derive(Parser)]
    pub struct OptimizeCommand {
        /// ä¼˜åŒ–ç­–ç•¥
        #[arg(long, default_value = "full")]
        pub strategy: OptimizationStrategy,
        
        /// ç”¨æˆ·IDè¿‡æ»¤
        #[arg(long)]
        pub user_id: Option<String>,
        
        /// Agent IDè¿‡æ»¤
        #[arg(long)]
        pub agent_id: Option<String>,
        
        /// è®°å¿†ç±»å‹è¿‡æ»¤
        #[arg(long)]
        pub memory_type: Option<MemoryType>,
        
        /// é¢„è§ˆæ¨¡å¼ï¼ˆä¸æ‰§è¡Œï¼‰
        #[arg(long)]
        pub preview: bool,
        
        /// æ¿€è¿›æ¨¡å¼ï¼ˆæ›´æ·±å±‚ä¼˜åŒ–ï¼‰
        #[arg(long)]
        pub aggressive: bool,
        
        /// è·³è¿‡ç¡®è®¤
        #[arg(long)]
        pub no_confirm: bool,
        
        /// è¶…æ—¶æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
        #[arg(long, default_value = "30")]
        pub timeout: u64,
    }
    
    #[derive(Parser)]
    pub struct OptimizationStatusCommand {
        /// æ˜¾ç¤ºè¯¦ç»†æŒ‡æ ‡
        #[arg(long)]
        pub detailed: bool,
        
        /// æ˜¾ç¤ºå†å²è®°å½•
        #[arg(long)]
        pub history: bool,
    }
    
    #[derive(Parser)]
    pub struct OptimizationConfigCommand {
        /// æ˜¾ç¤ºå½“å‰é…ç½®
        #[arg(long)]
        pub show: bool,
        
        /// æ›´æ–°é…ç½®
        #[arg(long)]
        pub update: bool,
        
        /// é…ç½®æ–‡ä»¶è·¯å¾„
        #[arg(conflicts_with = "show")]
        config_file: Option<String>,
    }
}
```

#### 3.1.2 å‘½ä»¤å®ç°

```rust
/// ä¼˜åŒ–å‘½ä»¤å®ç°
pub struct OptimizeCommandRunner {
    memory_manager: Arc<MemoryManager>,
    config: Config,
}

impl OptimizeCommandRunner {
    pub fn new(memory_manager: Arc<MemoryManager>, config: Config) -> Self {
        Self {
            memory_manager,
            config,
        }
    }
    
    pub async fn run_optimize(&self, cmd: &optimize::OptimizeCommand) -> Result<()> {
        // 1. æ„å»ºä¼˜åŒ–è¯·æ±‚
        let request = self.build_optimization_request(cmd)?;
        
        // 2. åˆ›å»ºä¼˜åŒ–å™¨
        let optimizer = self.create_optimizer().await?;
        
        // 3. æ‰§è¡Œä¼˜åŒ–
        if cmd.preview {
            self.run_preview(&optimizer, &request).await?;
        } else {
            self.run_optimization(&optimizer, &request, cmd.no_confirm).await?;
        }
        
        Ok(())
    }
    
    async fn create_optimizer(&self) -> Result<Arc<dyn MemoryOptimizer>> {
        let config = self.config.memory_config.clone();
        let optimization_config = config.optimization_config;
        
        let optimizer = DefaultMemoryOptimizer::new(
            self.memory_manager.clone(),
            optimization_config,
        ).await?;
        
        Ok(Arc::new(optimizer))
    }
    
    async fn run_preview(&self, optimizer: &dyn MemoryOptimizer, request: &OptimizationRequest) -> Result<()> {
        println!("ğŸ” ä¼˜åŒ–è®¡åˆ’é¢„è§ˆ");
        println!("ç­–ç•¥: {:?}", request.strategy);
        println!("è¿‡æ»¤å™¨: {:?}", request.filters);
        println!();
        
        let plan = optimizer.create_optimization_plan(request.strategy.clone()).await?;
        
        println!("ğŸ“‹ æ£€æµ‹åˆ°çš„é—®é¢˜:");
        for (i, issue) in plan.issues.iter().enumerate() {
            println!("  {}. {} - {}", i + 1, issue.severity, issue.description);
        }
        
        println!();
        println!("ğŸ¯ å»ºè®®çš„æ“ä½œ:");
        for (i, action) in plan.actions.iter().enumerate() {
            println!("  {}. {:?}", i + 1, action);
        }
        
        Ok(())
    }
    
    async fn run_optimization(&self, optimizer: &dyn MemoryOptimizer, request: &OptimizationRequest, no_confirm: bool) -> Result<()> {
        if !no_confirm {
            println!("âš ï¸  æ­¤æ“ä½œå°†ä¿®æ”¹æ‚¨çš„memoryæ•°æ®åº“");
            let input = prompt_for_confirmation("æ˜¯å¦ç»§ç»­? (y/N): ");
            if !input {
                println!("âŒ æ“ä½œå·²å–æ¶ˆ");
                return Ok(());
            }
        }
        
        println!("ğŸš€ å¼€å§‹æ‰§è¡Œä¼˜åŒ–...");
        
        let result = optimizer.optimize(request).await?;
        
        if result.success {
            println!("âœ… ä¼˜åŒ–å®Œæˆ!");
            println!("ğŸ“Š ä¼˜åŒ–ç»Ÿè®¡:");
            println!("  - æ‰§è¡Œæ—¶é—´: {:?}", result.end_time - result.start_time);
            println!("  - å‘ç°é—®é¢˜: {} ä¸ª", result.issues_found.len());
            println!("  - æ‰§è¡Œæ“ä½œ: {} ä¸ª", result.actions_performed.len());
            
            if let Some(metrics) = result.metrics {
                println!("  - èŠ‚çœç©ºé—´: {:.2} MB", metrics.saved_space_mb);
                println!("  - æ”¹å–„è´¨é‡: {:.2}%", metrics.quality_improvement * 100.0);
            }
        } else {
            println!("âŒ ä¼˜åŒ–å¤±è´¥: {}", result.error_message.unwrap_or("æœªçŸ¥é”™è¯¯"));
        }
        
        Ok(())
    }
}
```

### 3.2 å‘½ä»¤é›†æˆ

```rust
// åœ¨ main.rs ä¸­é›†æˆä¼˜åŒ–å‘½ä»¤
use crate::commands::optimize::{OptimizeCommand, OptimizationStatusCommand};

fn main() {
    let app = App::new("memo")
        .subcommand(
            Command::new("optimize")
                .about("ä¼˜åŒ–memoryæ•°æ®åº“")
                .arg(OptimizeCommand::command())
        )
        .subcommand(
            Command::new("optimize-status")
                .about("æŸ¥çœ‹ä¼˜åŒ–çŠ¶æ€")
                .arg(OptimizationStatusCommand::command())
        );
    
    let matches = app.get_matches();
    
    match matches.subcommand() {
        Some(("optimize", sub_matches)) => {
            let cmd = OptimizeCommand::from_arg_matches(sub_matches).unwrap();
            // æ‰§è¡Œä¼˜åŒ–å‘½ä»¤
        }
        Some(("optimize-status", sub_matches)) => {
            let cmd = OptimizationStatusCommand::from_arg_matches(sub_matches).unwrap();
            // æ˜¾ç¤ºä¼˜åŒ–çŠ¶æ€
        }
        _ => {}
    }
}
```

---

## 4. memo-service é›†æˆå®ç°

### 4.1 HTTP APIè®¾è®¡

#### 4.1.1 APIç«¯ç‚¹å®šä¹‰

```rust
/// ä¼˜åŒ–ç›¸å…³HTTPå¤„ç†å™¨
pub struct OptimizationHandlers {
    optimizer: Arc<dyn MemoryOptimizer>,
    trigger_manager: Arc<dyn TriggerManager>,
}

impl OptimizationHandlers {
    pub fn new(optimizer: Arc<dyn MemoryOptimizer>, trigger_manager: Arc<dyn TriggerManager>) -> Self {
        Self {
            optimizer,
            trigger_manager,
        }
    }
    
    /// æ‰§è¡Œä¼˜åŒ–
    pub async fn optimize(
        State(state): State<OptimizationAppState>,
        Json(request): Json<OptimizationRequest>,
    ) -> Result<Json<OptimizationResponse>, MemoryError> {
        // æƒé™æ£€æŸ¥
        // éªŒè¯è¯·æ±‚å‚æ•°
        // æ‰§è¡Œä¼˜åŒ–
        // è¿”å›ç»“æœ
    }
    
    /// è·å–ä¼˜åŒ–çŠ¶æ€
    pub async fn get_status(
        State(state): State<OptimizationAppState>,
    ) -> Result<Json<OptimizationStatusResponse>, MemoryError> {
        // è·å–å½“å‰ä¼˜åŒ–çŠ¶æ€
    }
    
    /// è·å–ä¼˜åŒ–å†å²
    pub async fn get_history(
        State(state): State<OptimizationAppState>,
        Query(params): Query<HistoryQueryParams>,
    ) -> Result<Json<OptimizationHistoryResponse>, MemoryError> {
        // è·å–ä¼˜åŒ–å†å²è®°å½•
    }
    
    /// åˆ›å»ºå®šæ—¶è§¦å‘å™¨
    pub async fn create_schedule(
        State(state): State<OptimizationAppState>,
        Json(request): Json<CreateScheduleRequest>,
    ) -> Result<Json<CreateScheduleResponse>, MemoryError> {
        // åˆ›å»ºå®šæ—¶è§¦å‘å™¨
    }
    
    /// åˆ é™¤å®šæ—¶è§¦å‘å™¨
    pub async fn delete_schedule(
        State(state): State<OptimizationAppState>,
        Path(schedule_id): Path<String>,
    ) -> Result<Json<DeleteScheduleResponse>, MemoryError> {
        // åˆ é™¤å®šæ—¶è§¦å‘å™¨
    }
}
```

#### 4.1.2 è¯·æ±‚å“åº”æ¨¡å‹

```rust
/// ä¼˜åŒ–è¯·æ±‚
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationRequest {
    pub optimization_id: Option<String>,
    pub strategy: OptimizationStrategy,
    pub filters: OptimizationFilters,
    pub aggressive: Option<bool>,
    pub timeout_minutes: Option<u64>,
}

/// ä¼˜åŒ–å“åº”
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationResponse {
    pub optimization_id: String,
    pub status: OptimizationStatus,
    pub started_at: DateTime<Utc>,
    pub estimated_completion: Option<DateTime<Utc>>,
    pub message: String,
}

/// ä¼˜åŒ–çŠ¶æ€å“åº”
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationStatusResponse {
    pub current_optimizations: Vec<OptimizationStatus>,
    pub last_optimization: Option<OptimizationSummary>,
    pub system_metrics: SystemMetrics,
}

/// åˆ›å»ºå®šæ—¶è§¦å‘å™¨è¯·æ±‚
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateScheduleRequest {
    pub name: String,
    pub description: Option<String>,
    pub cron_expression: String,
    pub strategy: OptimizationStrategy,
    pub filters: Option<OptimizationFilters>,
    pub enabled: Option<bool>,
}

/// åˆ›å»ºå®šæ—¶è§¦å‘å™¨å“åº”
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateScheduleResponse {
    pub schedule_id: String,
    pub created_at: DateTime<Utc>,
    pub message: String,
}
```

### 4.2 è·¯ç”±é…ç½®

```rust
/// ä¼˜åŒ–ç›¸å…³è·¯ç”±
pub fn optimization_routes() -> Router {
    Router::new()
        .route("/optimize", post(optimize_handler))
        .route("/optimize/status", get(get_status_handler))
        .route("/optimize/history", get(get_history_handler))
        .route("/optimize/schedules", post(create_schedule_handler))
        .route("/optimize/schedules/:id", delete(delete_schedule_handler))
        .route("/optimize/schedules", get(list_schedules_handler))
}

/// ä¼˜åŒ–å¤„ç†å™¨
async fn optimize_handler(
    State(app_state): State<OptimizationAppState>,
    Json(request): Json<OptimizationRequest>,
) -> Result<Json<OptimizationResponse>, MemoryError> {
    let handlers = OptimizationHandlers::new(
        app_state.optimizer.clone(),
        app_state.trigger_manager.clone(),
    );
    
    handlers.optimize(State(app_state), Json(request)).await
}

async fn get_status_handler(
    State(app_state): State<OptimizationAppState>,
) -> Result<Json<OptimizationStatusResponse>, MemoryError> {
    let handlers = OptimizationHandlers::new(
        app_state.optimizer.clone(),
        app_state.trigger_manager.clone(),
    );
    
    handlers.get_status(State(app_state)).await
}

// å…¶ä»–å¤„ç†å™¨å®ç°...
```

### 4.3 åº”ç”¨çŠ¶æ€é›†æˆ

```rust
/// ä¼˜åŒ–åº”ç”¨çŠ¶æ€
pub struct OptimizationAppState {
    pub optimizer: Arc<dyn MemoryOptimizer>,
    pub trigger_manager: Arc<dyn TriggerManager>,
    pub config: OptimizationConfig,
}

impl OptimizationAppState {
    pub fn new(
        memory_manager: Arc<MemoryManager>,
        config: AppConfig,
    ) -> Result<Self> {
        let optimization_config = config.memory_config.optimization_config.clone();
        
        let optimizer = DefaultMemoryOptimizer::new(
            memory_manager.clone(),
            optimization_config.clone(),
        ).await?;
        
        let trigger_manager = DefaultTriggerManager::new(
            optimizer.clone(),
            optimization_config.trigger_config.clone(),
        ).await?;
        
        Ok(Self {
            optimizer,
            trigger_manager,
            config: optimization_config,
        })
    }
}

/// åœ¨æœåŠ¡å¯åŠ¨æ—¶åˆå§‹åŒ–
#[tokio::main]
async fn main() -> Result<()> {
    let app_state = OptimizationAppState::new(
        memory_manager,
        config,
    )?;
    
    let app = Router::new()
        .nest("/api", optimization_routes())
        .with_state(app_state);
    
    axum::serve(listener, app).await?;
    Ok(())
}
```

---

## 5. é…ç½®æ–‡ä»¶é›†æˆ

### 5.1 ä¸»é…ç½®æ–‡ä»¶æ‰©å±•

```toml
# config.toml

[optimization]
enabled = true

[optimization.trigger_config]
auto_triggers = [
    {
        name = "weekly_full_optimize",
        enabled = true,
        strategy = "Full",
        schedule = "0 2 * * 0",  # æ¯å‘¨æ—¥å‡Œæ™¨2ç‚¹
        thresholds = {
            max_memory_count = 5000,
            duplicate_ratio = 0.2
        }
    },
    {
        name = "daily_incremental_optimize", 
        enabled = true,
        strategy = "Incremental",
        schedule = "0 1 * * *",  # æ¯å¤©å‡Œæ™¨1ç‚¹
        thresholds = {
            access_frequency = 0.1
        }
    }
]

[optimization.strategy_configs.deduplication]
semantic_threshold = 0.85
content_threshold = 0.7
metadata_threshold = 0.8
merge_threshold = 0.9
max_batch_size = 1000

[optimization.strategy_configs.relevance]
time_decay_days = 30
min_access_frequency = 0.05
importance_threshold = 0.3

[optimization.strategy_configs.quality]
min_content_length = 10
quality_score_threshold = 0.4

[optimization.strategy_configs.space]
max_memory_per_type = 5000
archive_after_days = 90

[optimization.execution_config]
batch_size = 100
max_concurrent_tasks = 4
timeout_minutes = 30
retry_attempts = 3

[optimization.safety_config]
auto_backup = true
backup_retention_days = 7
max_optimization_duration_hours = 2
```

### 5.2 é…ç½®åŠ è½½é€»è¾‘

```rust
/// ä¼˜åŒ–é…ç½®åŠ è½½å™¨
pub struct OptimizationConfigLoader {
    config_path: PathBuf,
}

impl OptimizationConfigLoader {
    pub fn new(config_path: impl Into<PathBuf>) -> Self {
        Self {
            config_path: config_path.into(),
        }
    }
    
    pub async fn load_config(&self) -> Result<OptimizationConfig> {
        let content = tokio::fs::read_to_string(&self.config_path).await?;
        let config: OptimizationConfig = toml::from_str(&content)?;
        
        // éªŒè¯é…ç½®
        self.validate_config(&config)?;
        
        Ok(config)
    }
    
    pub async fn save_config(&self, config: &OptimizationConfig) -> Result<()> {
        let content = toml::to_string_pretty(config)?;
        tokio::fs::write(&self.config_path, content).await?;
        Ok(())
    }
    
    fn validate_config(&self, config: &OptimizationConfig) -> Result<()> {
        // éªŒè¯é…ç½®å‚æ•°çš„æœ‰æ•ˆæ€§
        if config.strategy_configs.deduplication.semantic_threshold < 0.0 
            || config.strategy_configs.deduplication.semantic_threshold > 1.0 {
            return Err(MemoryError::Config("Invalid semantic threshold".into()));
        }
        
        // å…¶ä»–éªŒè¯é€»è¾‘...
        
        Ok(())
    }
}
```

---

## 6. å®æ–½è®¡åˆ’å’Œé‡Œç¨‹ç¢‘

### 6.1 å®æ–½é˜¶æ®µ

#### ç¬¬ä¸€é˜¶æ®µ: æ ¸å¿ƒæ¡†æ¶ (2å‘¨)
- [ ] åœ¨ `cortex-mem-core` ä¸­åˆ›å»ºåŸºç¡€ä¼˜åŒ–æ¨¡å—ç»“æ„
- [ ] å®ç° `MemoryOptimizer` æ ¸å¿ƒæ¥å£
- [ ] å®ç°åŸºç¡€çš„ `OptimizationDetector`
- [ ] å®ç°åŸºç¡€çš„ `ExecutionEngine`

#### ç¬¬äºŒé˜¶æ®µ: ä¼˜åŒ–ç­–ç•¥ (2å‘¨)
- [ ] å®ç° `DeduplicationStrategy`
- [ ] å®ç° `RelevanceStrategy`
- [ ] å®ç° `QualityStrategy`
- [ ] å®ç° `SpaceStrategy`

#### ç¬¬ä¸‰é˜¶æ®µ: CLIé›†æˆ (1å‘¨)
- [ ] å®ç° `memo optimize` å‘½ä»¤
- [ ] é›†æˆåˆ°ç°æœ‰çš„CLIæ¶æ„ä¸­
- [ ] æ·»åŠ é…ç½®ç®¡ç†åŠŸèƒ½

#### ç¬¬å››é˜¶æ®µ: Serviceé›†æˆ (1å‘¨)
- [ ] å®ç°HTTP APIå¤„ç†å™¨
- [ ] æ·»åŠ è·¯ç”±é…ç½®
- [ ] é›†æˆåˆ°æœåŠ¡å¯åŠ¨æµç¨‹

#### ç¬¬äº”é˜¶æ®µ: æµ‹è¯•å’Œä¼˜åŒ– (1å‘¨)
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•å’Œè°ƒä¼˜
- [ ] æ–‡æ¡£å®Œå–„

### 6.2 å…³é”®é£é™©å’Œç¼“è§£

#### é£é™©1: ä¼˜åŒ–æ“ä½œå½±å“ç³»ç»Ÿæ€§èƒ½
**ç¼“è§£æªæ–½**:
- å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡ä¸»æœåŠ¡
- é…ç½®é™æµå’Œæ‰¹å¤„ç†å¤§å°
- æä¾›æ‰§è¡Œè¿›åº¦ç›‘æ§

#### é£é™©2: ä¼˜åŒ–è¯¯åˆ é‡è¦è®°å¿†
**ç¼“è§£æªæ–½**:
- å¼ºåˆ¶å¯ç”¨å¤‡ä»½æœºåˆ¶
- æä¾›å›æ»šåŠŸèƒ½
- é¢„è§ˆæ¨¡å¼å’Œç¡®è®¤æœºåˆ¶

#### é£é™©3: ä¼˜åŒ–ç®—æ³•æ•ˆæœä¸ä½³
**ç¼“è§£æªæ–½**:
- å¯é…ç½®çš„é˜ˆå€¼å’Œç­–ç•¥
- A/Bæµ‹è¯•ä¸åŒç®—æ³•å‚æ•°
- æŒç»­ç›‘æ§å’Œè°ƒä¼˜

### 6.3 æˆåŠŸæ ‡å‡†

1. **åŠŸèƒ½å®Œæ•´æ€§**: æ‰€æœ‰ä¼˜åŒ–ç­–ç•¥æ­£å¸¸å·¥ä½œ
2. **æ€§èƒ½å½±å“**: ä¼˜åŒ–æ“ä½œå¯¹ç³»ç»Ÿæ€§èƒ½å½±å“ < 5%
3. **å®‰å…¨å¯é æ€§**: 0%æ•°æ®ä¸¢å¤±ï¼Œæä¾›å®Œæ•´çš„å¤‡ä»½å›æ»š
4. **ç”¨æˆ·æ»¡æ„åº¦**: CLIå’ŒAPIä½¿ç”¨ä¾¿åˆ©ï¼Œé…ç½®çµæ´»
5. **æ•ˆæœéªŒè¯**: ä¿¡æ¯å¯†åº¦æå‡ > 20%ï¼Œæœç´¢æ€§èƒ½æå‡ > 15%

---

## 7. æ€»ç»“

è¿™ä¸ªæ¶æ„å®ç°è®¾è®¡ä¸ºcortex-memç³»ç»Ÿæä¾›äº†å®Œæ•´çš„ä¸»åŠ¨ä¼˜åŒ–èƒ½åŠ›ï¼š

### æ ¸å¿ƒä¼˜åŠ¿
1. **æ¨¡å—åŒ–è®¾è®¡**: æ ¸å¿ƒèƒ½åŠ›å°è£…åœ¨mem-coreä¸­ï¼Œæ¸…æ™°çš„åˆ†å±‚æ¶æ„
2. **ç»Ÿä¸€æ¥å£**: é€šè¿‡CLIå’ŒServiceæä¾›ä¸€è‡´çš„è§¦å‘æ–¹å¼
3. **é«˜åº¦å¯é…ç½®**: é€‚åº”ä¸åŒåœºæ™¯éœ€æ±‚çš„çµæ´»é…ç½®
4. **å®‰å…¨å¯é **: å®Œå–„çš„å¤‡ä»½å›æ»šå’Œå®‰å…¨æœºåˆ¶
5. **å¼‚æ­¥é«˜æ•ˆ**: ä¸å½±å“æ­£å¸¸æœåŠ¡çš„å¼‚æ­¥æ‰§è¡Œ

### æŠ€æœ¯ç‰¹è‰²
- **ç­–ç•¥åŒ–ä¼˜åŒ–**: å››å¤§ä¼˜åŒ–ç­–ç•¥è¦†ç›–ä¸åŒç»´åº¦
- **æ™ºèƒ½è§¦å‘**: è‡ªåŠ¨å’Œæ‰‹åŠ¨è§¦å‘æœºåˆ¶ç»“åˆ
- **å®æ—¶ç›‘æ§**: å®Œæ•´çš„è¿›åº¦ç›‘æ§å’Œç»“æœæŠ¥å‘Š
- **æ¸è¿›éƒ¨ç½²**: æ”¯æŒåˆ†é˜¶æ®µå®æ–½å’ŒéªŒè¯

è¿™ä¸ªæ–¹æ¡ˆå°†æœ‰æ•ˆè§£å†³cortex-memç³»ç»Ÿé¢ä¸´çš„ä¿¡æ¯å¯†åº¦å’Œæœ‰æ•ˆæ€§åŠ£åŒ–é—®é¢˜ï¼Œä¸ºç³»ç»Ÿçš„é•¿æœŸå¥åº·è¿è¡Œæä¾›åšå®ä¿éšœã€‚