# System Boundary Interface Documentation

This document describes the system's external invocation interfaces, including CLI commands, API endpoints, configuration parameters, and other boundary mechanisms.

## Command Line Interface (CLI)

### cortex-mem-cli

**Description**: Main CLI interface for memory management operations

**Source File**: `cortex-mem-cli/src/main.rs`

**Arguments**:

- `command` (Commands): required - Subcommand to execute (add, delete, list, search)
- `config` (PathBuf): optional - Path to configuration file (default: `config.toml`)

**Usage Examples**:

```bash
cortex-mem-cli add --content "Meeting notes" --user-id user123
```

```bash
cortex-mem-cli search "project timeline" --user-id user123
```

```bash
cortex-mem-cli list --agent-id agent456 --limit 10
```

### cortex-mem-mcp

**Description**: MCP server for memory operations over stdio transport

**Source File**: `cortex-mem-mcp/src/main.rs`

**Arguments**:

- `config` (PathBuf): optional - Path to the TOML configuration file (default: `config.toml`)
- `agent` (String): optional - Optional agent identifier used for scoping memory operations

**Usage Examples**:

```bash
cortex-mem-mcp --config /path/to/config.toml
```

```bash
cortex-mem-mcp --agent agent123
```

### cortex-mem-tars

**Description**: Terminal-based interactive AI assistant with memory integration

**Source File**: `examples/cortex-mem-tars/src/main.rs`

**Arguments**:

- `config` (PathBuf): optional - Configuration file path parameter (default: `config.toml`)

**Usage Examples**:

```bash
cortex-mem-tars --config config.prod.toml
```

### cortex-mem-service

**Description**: HTTP service for memory operations

**Source File**: `cortex-mem-service/src/main.rs`

**Usage Examples**:

```bash
cortex-mem-service
```

## API Interfaces

### GET /health

**Description**: Health check endpoint that verifies the overall system health including vector store and LLM service

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: Json<HealthResponse>

### POST /memories

**Description**: Creates a new memory with support for both simple content and conversation-based procedural memory

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: Json<CreateMemoryRequest>

**Response Format**: Json<SuccessResponse>

### GET /memories/{id}

**Description**: Retrieves a specific memory by its ID

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: Json<MemoryResponse>

### PUT /memories/{id}

**Description**: Updates an existing memory with new content

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: Json<UpdateMemoryRequest>

**Response Format**: Json<SuccessResponse>

### DELETE /memories/{id}

**Description**: Deletes a memory by its ID

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: Json<SuccessResponse>

### POST /search

**Description**: Searches memories using similarity matching with optional filters

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: Json<SearchMemoryRequest>

**Response Format**: Json<SearchResponse>

### GET /memories

**Description**: Lists memories with optional filtering and pagination

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: Query<ListMemoryQuery>

**Response Format**: Json<ListResponse>

### POST /batch-delete

**Description**: Performs batch deletion of multiple memories

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: Json<BatchDeleteRequest>

**Response Format**: Json<BatchOperationResponse>

### POST /batch-update

**Description**: Performs batch update of multiple memories

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: Json<BatchUpdateRequest>

**Response Format**: Json<BatchOperationResponse>

### POST /optimization

**Description**: Initiates a new optimization task with the specified parameters

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Request Format**: Json<StartOptimizationRequest>

**Response Format**: Json<OptimizationResponse>

### GET /optimization/{job_id}

**Description**: Retrieves the current status and progress of a specific optimization job

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Response Format**: Json<OptimizationResponse>

### POST /optimization/{job_id}/cancel

**Description**: Cancels a running optimization job if it hasn't completed

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Response Format**: Json<OptimizationResponse>

## Router Routes

### /

**Description**: Dashboard page component that manages dashboard state, loads data on mount, calculates derived metrics, handles errors with fallback data

**Source File**: `cortex-mem-insights/src/routes/+page.svelte`

### /optimization

**Description**: Optimization dashboard component that manages complete optimization lifecycle (initiation, execution, monitoring), provides UI for strategy selection and configuration

**Source File**: `cortex-mem-insights/src/routes/optimization/+page.svelte`

### /layout

**Description**: Layout component providing consistent structure across all pages, imports global styles, tracks current route path via $page store

**Source File**: `cortex-mem-insights/src/routes/+layout.svelte`

## Integration Suggestions

### API

Use the TypeScript client for seamless integration with the Cortex Memory Service API

**Example Code**:

```
import { cortexMemService } from './integrations/cortex-mem';\n\nconst client = new cortexMemService('http://localhost:8080');\nconst response = await client.listMemories({ user_id: 'user123', limit: 10 });
```

**Best Practices**:

- Use environment variables for API endpoints
- Implement proper error handling around API calls
- Cache responses when appropriate to reduce latency
- Use typed interfaces for type safety

### CLI

Integrate CLI commands into your deployment pipelines or scripts

**Example Code**:

```
#!/bin/bash\n# Script to backup memories regularly\nUSER_ID="${1:-user123}"\nBACKUP_DIR="/backups/memories/$(date +%Y%m%d)"\n\nmkdir -p "$BACKUP_DIR"\n\ncortex-mem-cli list --user-id "$USER_ID" --format json > "$BACKUP_DIR/memories.json"\necho "Backup completed: $BACKUP_DIR/memories.json"
```

**Best Practices**:

- Use configuration files for complex setups
- Implement logging in wrapper scripts
- Handle exit codes appropriately
- Use absolute paths in production environments

### Monitoring

Set up monitoring for system health and performance metrics

**Example Code**:

```
import { systemApi } from '$lib/api/client';\n\nsetInterval(async () => {\n  try {\n    const status = await systemApi.getStatus();\n    if (status.overall_status !== 'healthy') {\n      // Send alert or notification\n      console.error('System health degraded:', status);\n    }\n  } catch (error) {\n    console.error('Failed to check system status:', error);\n  }\n}, 30000); // Check every 30 seconds
```

**Best Practices**:

- Monitor both application and system metrics
- Set up alerts for critical failures
- Log monitoring data for trend analysis
- Use exponential backoff for retry logic


---

**Analysis Confidence**: 9.5/10
