# System Boundary Interface Documentation

This document describes the system's external invocation interfaces, including CLI commands, API endpoints, configuration parameters, and other boundary mechanisms.

## Command Line Interface (CLI)

### cortex-mem-cli

**Description**: Rust Agent Memory System CLI that provides commands for adding, searching, listing, and deleting memories, as well as optimization-related operations.

**Source File**: `cortex-mem-cli/src/main.rs`

**Arguments**:

- `config` (PathBuf): optional - Path to the configuration file, defaults to config.toml (default: `config.toml`)

**Options**:

- `content, c`(String): required - Content to store as memory
- `user_id, u`(String): optional - User ID for the memory
- `agent_id, a`(String): optional - Agent ID for the memory
- `memory_type, t`(String): optional - Memory type (conversational, procedural, factual) (default: `conversational`)
- `query, q`(String): optional - Search query (optional - if not provided, will use only metadata filters)
- `topics`(Vec<String>): optional - Topics filter (comma-separated)
- `keywords`(Vec<String>): optional - Keywords filter (comma-separated)
- `limit, l`(usize): optional - Maximum number of results (default: `10`)
- `id`(String): required - Memory ID to delete

**Usage Examples**:

```bash
# Add a new memory\ncortex-mem-cli add --content "Meeting notes" --user-id user123 --memory-type conversational
```

```bash
# Search for memories\ncortex-mem-cli search --query "project status" --user-id user123 --limit 5
```

```bash
# List all memories for a user\ncortex-mem-cli list --user-id user123
```

```bash
# Delete a memory\ncortex-mem-cli delete mem_abc123
```

```bash
# Optimize memory database\ncortex-mem-cli optimize
```

### cortex-mem-mcp

**Description**: MCP server for Cortex Memo memory management system that serves as an MCP service over stdio with configuration and agent identifier options.

**Source File**: `cortex-mem-mcp/src/main.rs`

**Arguments**:

- `config` (PathBuf): optional - Path to the configuration file (default: `config.toml`)
- `agent` (String): optional - Agent identifier for memory operations

**Usage Examples**:

```bash
# Start MCP server with default config\ncortex-mem-mcp
```

```bash
# Start MCP server with custom config and agent ID\ncortex-mem-mcp --config /path/to/config.toml --agent my-agent-001
```

### cortex-mem-evaluation

**Description**: Evaluation framework for assessing Cortex-Mem core capabilities including recall, effectiveness, performance, and dataset generation/validation.

**Source File**: `examples/cortex-mem-evaluation/src/main.rs`

**Options**:

- `config, c`(PathBuf): optional - Configuration file path (default: `config/evaluation_config.toml`)
- `output_dir, o`(PathBuf): optional - Output directory for results (default: `results`)
- `dataset_type, d`(String): optional - Data set type: recall, effectiveness, all (default: `all`)
- `size, s`(usize): optional - Dataset size (default: `100`)
- `use_lab_data`(bool): optional - Whether to use laboratory data (default: `true`)
- `dataset_path, p`(PathBuf): required - Path to the dataset
- `dataset_type, t`(String): required - Dataset type: recall, effectiveness

**Usage Examples**:

```bash
# Run full evaluation\ncortex-mem-evaluation run --config config/evaluation_config.toml --output-dir results
```

```bash
# Run recall evaluation only\ncortex-mem-evaluation recall --config config/evaluation_config.toml
```

```bash
# Generate test dataset\ncortex-mem-evaluation generate-dataset --dataset-type all --size 1000
```

```bash
# Validate dataset\ncortex-mem-evaluation validate-dataset --dataset-path data/test_dataset.json --dataset-type recall
```

### cortex-mem-service

**Description**: HTTP Service for Rust Agent Memory System that provides RESTful API endpoints for memory management and optimization tasks.

**Source File**: `cortex-mem-service/src/main.rs`

**Arguments**:

- `config` (PathBuf): optional - Path to the configuration file (default: `config.toml`)

**Usage Examples**:

```bash
# Start HTTP service with default config\ncortex-mem-service
```

```bash
# Start HTTP service with custom config\ncortex-mem-service --config /path/to/custom-config.toml
```

### multi-round-interactive

**Description**: Multi-round interactive conversation with a memory-enabled agent using TUI interface, supporting graceful shutdown with background memory persistence.

**Source File**: `examples/cortex-mem-tars/src/main.rs`

**Arguments**:

- `config` (PathBuf): optional - Path to the configuration file (default: `config.toml`)

**Usage Examples**:

```bash
# Start interactive session with default config\nmulti-round-interactive
```

```bash
# Start interactive session with custom config\nmulti-round-interactive --config /path/to/config.toml
```

## API Interfaces

### GET /health

**Description**: Health check endpoint to verify system health including vector store and LLM service connectivity.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: {\n  "status": "healthy" | "unhealthy",\n  "vector_store": boolean,\n  "llm_service": boolean,\n  "timestamp": string\n}

### POST /memories

**Description**: Create a new memory with content and optional metadata such as user ID, agent ID, and memory type.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: {\n  "content": string,\n  "user_id"?: string,\n  "agent_id"?: string,\n  "run_id"?: string,\n  "actor_id"?: string,\n  "role"?: string,\n  "memory_type"?: string,\n  "custom"?: Record<string, any>\n}

**Response Format**: {\n  "message": string,\n  "id": string\n}

### GET /memories

**Description**: List memories with optional filtering by user ID, agent ID, run ID, actor ID, memory type, and limit.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: ?user_id=string&agent_id=string&run_id=string&actor_id=string&memory_type=string&limit=number

**Response Format**: {\n  "total": number,\n  "memories": Array<{\n    "id": string,\n    "content": string,\n    "metadata": {\n      "user_id"?: string,\n      "agent_id"?: string,\n      "run_id"?: string,\n      "actor_id"?: string,\n      "role"?: string,\n      "memory_type": string,\n      "hash": string,\n      "custom": Record<string, any>\n    },\n    "created_at": string,\n    "updated_at": string\n  }>\n}

### POST /memories/search

**Description**: Search memories by semantic similarity using a query string with optional filters and similarity threshold.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: {\n  "query": string,\n  "user_id"?: string,\n  "agent_id"?: string,\n  "run_id"?: string,\n  "actor_id"?: string,\n  "memory_type"?: string,\n  "limit"?: number,\n  "similarity_threshold"?: number\n}

**Response Format**: {\n  "total": number,\n  "results": Array<{\n    "memory": MemoryResponse,\n    "score": number\n  }>\n}

### GET /memories/{id}

**Description**: Retrieve a specific memory by its unique identifier.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: {\n  "id": string,\n  "content": string,\n  "metadata": {\n    "user_id"?: string,\n    "agent_id"?: string,\n    "run_id"?: string,\n    "actor_id"?: string,\n    "role"?: string,\n    "memory_type": string,\n    "hash": string,\n    "custom": Record<string, any>\n  },\n  "created_at": string,\n  "updated_at": string\n}

### PUT /memories/{id}

**Description**: Update the content of an existing memory identified by its ID.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Request Format**: {\n  "content": string\n}

**Response Format**: {\n  "message": string,\n  "id": string\n}

### DELETE /memories/{id}

**Description**: Delete a memory by its unique identifier.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: {\n  "message": string,\n  "id": string\n}

### POST /optimization

**Description**: Start a new memory optimization task with optional parameters for memory type, user/agent IDs, and optimization strategy.

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Request Format**: {\n  "memory_type"?: string,\n  "user_id"?: string,\n  "agent_id"?: string,\n  "run_id"?: string,\n  "actor_id"?: string,\n  "similarity_threshold"?: number,\n  "dry_run"?: boolean,\n  "verbose"?: boolean,\n  "strategy"?: string,\n  "aggressive"?: boolean,\n  "timeout_minutes"?: number\n}

**Response Format**: {\n  "success": boolean,\n  "data"?: any,\n  "error"?: {\n    "code": string,\n    "message": string\n  },\n  "timestamp": string\n}

### GET /optimization/{jobId}

**Description**: Get the current status of a specific optimization job by its job identifier.

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Response Format**: {\n  "success": boolean,\n  "data"?: {\n    "job_id": string,\n    "status": string,\n    "progress": number,\n    "current_phase": string,\n    "logs": string[],\n    "result"?: OptimizationResult,\n    "start_time": string,\n    "end_time"?: string,\n    "duration"?: number\n  },\n  "error"?: {\n    "code": string,\n    "message": string\n  },\n  "timestamp": string\n}

### POST /optimization/{jobId}/cancel

**Description**: Cancel a running optimization job identified by its job ID.

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Response Format**: {\n  "success": boolean,\n  "data"?: {\n    "job_id": string,\n    "message": string,\n    "status": "cancelled",\n    "cancelled_at": string\n  },\n  "error"?: {\n    "code": string,\n    "message": string\n  },\n  "timestamp": string\n}

### GET /optimization/history

**Description**: Retrieve historical records of optimization jobs with optional pagination and filtering.

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Request Format**: ?limit=number&offset=number&status=string&start_date=string&end_date=string

**Response Format**: {\n  "success": boolean,\n  "data"?: {\n    "total": number,\n    "history": Array<{\n      "job_id": string,\n      "status": string,\n      "start_time": string,\n      "end_time"?: string,\n      "duration"?: number,\n      "logs_count": number,\n      "has_result": boolean\n    }>,\n    "pagination": {\n      "limit": number,\n      "offset": number,\n      "total": number\n    }\n  },\n  "error"?: {\n    "code": string,\n    "message": string\n  },\n  "timestamp": string\n}

### GET /optimization/statistics

**Description**: Get statistical information about optimization jobs including success rates, durations, and processed memories.

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Response Format**: {\n  "success": boolean,\n  "data"?: {\n    "total_jobs": number,\n    "successful_jobs": number,\n    "failed_jobs": number,\n    "cancelled_jobs": number,\n    "total_memories_processed": number,\n    "avg_duration": number,\n    "last_run"?: string\n  },\n  "error"?: {\n    "code": string,\n    "message": string\n  },\n  "timestamp": string\n}

### POST /optimization/analyze

**Description**: Analyze potential optimization opportunities in preview mode without making changes (dry-run).

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Request Format**: {\n  "memory_type"?: string,\n  "user_id"?: string,\n  "agent_id"?: string,\n  "run_id"?: string,\n  "actor_id"?: string,\n  "similarity_threshold"?: number\n}

**Response Format**: {\n  "success": boolean,\n  "data"?: {\n    "issues": Array<Issue>,\n    "summary": {\n      "total_issues": number,\n      "total_affected_memories": number,\n      "estimated_savings_mb": number,\n      "estimated_duration_minutes": number\n    },\n    "recommendations": Array<{\n      "type": string,\n      "action": string,\n      "priority": string\n    }>\n  },\n  "error"?: {\n    "code": string,\n    "message": string\n  },\n  "timestamp": string\n}

### POST /optimization/cleanup

**Description**: Clean up old optimization history records based on age criteria.

**Source File**: `cortex-mem-service/src/optimization_handlers.rs`

**Request Format**: {\n  "max_age_days": number\n}

**Response Format**: {\n  "success": boolean,\n  "data"?: {\n    "deleted": number,\n    "remaining": number,\n    "message": string\n  },\n  "error"?: {\n    "code": string,\n    "message": string\n  },\n  "timestamp": string\n}

### GET /llm/status

**Description**: Get detailed status of LLM services including completion and embedding model availability and latency.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: {\n  "overall_status": string,\n  "completion_model": {\n    "available": boolean,\n    "provider": string,\n    "model_name": string,\n    "latency_ms"?: number,\n    "error_message"?: string,\n    "last_check": string\n  },\n  "embedding_model": {\n    "available": boolean,\n    "provider": string,\n    "model_name": string,\n    "latency_ms"?: number,\n    "error_message"?: string,\n    "last_check": string\n  },\n  "timestamp": string\n}

### GET /llm/health-check

**Description**: Simple health check for LLM service availability.

**Source File**: `cortex-mem-service/src/handlers.rs`

**Response Format**: {\n  "completion_model_available": boolean,\n  "embedding_model_available": boolean,\n  "timestamp": string\n}

## Router Routes

### /

**Description**: Dashboard page showing overall system status and key metrics.

**Source File**: `cortex-mem-insights/src/routes/+layout.svelte`

### /memories

**Description**: Memory Browser page for viewing, searching, and managing stored memories.

**Source File**: `cortex-mem-insights/src/routes/+layout.svelte`

### /analytics

**Description**: Analytics page for visualizing memory usage patterns, statistics, and trends.

**Source File**: `cortex-mem-insights/src/routes/+layout.svelte`

### /optimization

**Description**: Optimization Panel page for managing memory optimization tasks and viewing their status.

**Source File**: `cortex-mem-insights/src/routes/+layout.svelte`

### /monitor

**Description**: System Monitor page for monitoring real-time system health, performance metrics, and logs.

**Source File**: `cortex-mem-insights/src/routes/+layout.svelte`

## Integration Suggestions

### CLI

Integrate CLI tools into automated workflows and scripts for batch memory operations and system maintenance.

**Example Code**:

```
#!/bin/bash\n# Script to regularly optimize memory database\necho "Starting daily memory optimization..."\ncortex-mem-cli optimize --config /etc/cortex-mem/config.toml\necho "Memory optimization completed at $(date)"
```

**Best Practices**:

- Use configuration files instead of command-line arguments for production deployments
- Implement proper error handling when calling CLI tools programmatically
- Schedule optimization tasks during low-usage periods to minimize impact on performance
- Monitor exit codes and log outputs for automated task debugging

### API

Integrate with the REST API for building custom applications and dashboards that interact with the memory system.

**Example Code**:

```
import axios from 'axios';

// Configure API client
const api = axios.create({
  baseURL: 'http://localhost:3000',
  timeout: 10000,
});

// Function to search memories
async function searchMemories(query, filters = {}) {
  try {
    const response = await api.post('/memories/search', {
      query,
      ...filters
    });
    return response.data;
  } catch (error) {
    console.error('Search failed:', error);
    throw error;
  }
}

// Function to create a memory
async function createMemory(content, metadata = {}) {
  try {
    const response = await api.post('/memories', {
      content,
      ...metadata
    });
    return response.data;
  } catch (error) {
    console.error('Create memory failed:', error);
    throw error;
  }
}
```

**Best Practices**:

- Use environment variables for API base URLs to support different deployment environments
- Implement retry logic with exponential backoff for transient failures
- Handle authentication if added in future versions
- Validate responses before processing to ensure data integrity
- Monitor API usage and implement rate limiting in client code

### Config

Configure the system through TOML configuration files to customize behavior across different environments.

**Example Code**:

```
# config.toml
[server]
host = "0.0.0.0"
port = 3000
cors_origins = ["http://localhost:5173", "https://your-app.com"]

[qdrant]
url = "http://localhost:6334"
collection_name = "memories"
embedding_dim = 1536
timeout_secs = 30

[llm]
api_base_url = "https://api.openai.com/v1"
api_key = "${LLM_API_KEY}"
model_efficient = "gpt-3.5-turbo"
temperature = 0.7
max_tokens = 1000

[memory]
max_memories = 10000
similarity_threshold = 0.65
max_search_results = 50
auto_summary_threshold = 32768
auto_enhance = true
deduplicate = true
merge_threshold = 0.75
search_similarity_threshold = 0.70

[logging]
enabled = true
log_directory = "logs"
level = "info"
```

**Best Practices**:

- Use environment variable substitution in configuration files for sensitive data
- Keep separate configuration files for development, staging, and production environments
- Set appropriate similarity thresholds based on your use case (higher for precision, lower for recall)
- Configure CORS origins properly to allow legitimate frontend applications while preventing unauthorized access
- Regularly review and update configuration settings as system requirements evolve

### Security

Secure the system against common vulnerabilities by implementing proper authentication, input validation, and secure configuration practices.

**Example Code**:

```
# Secure configuration example

# 1. Use environment variables for secrets
cat > .env << 'EOL'
LLM_API_KEY=sk-your-secret-key-here
DATABASE_PASSWORD=strong-db-password
EOL

# 2. Update config.toml to use environment variables
[llm]
api_key = "${LLM_API_KEY}"  # Will be loaded from environment

# 3. Set proper file permissions
chmod 600 .env          # Read/write for owner only
chmod 644 config.toml # Readable by owner, readable by group/others

# 4. Example nginx reverse proxy configuration for additional security
server {
    listen 80;
    server_name cortex-mem.example.com;
    
    location / {
        # Rate limiting: max 100 requests per minute per IP
        limit_req zone=api_limit burst=20 nodelay;
        
        # Forward to backend service
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # Security headers
        add_header X-Frame-Options "DENY";
        add_header X-Content-Type-Options "nosniff";
        add_header Content-Security-Policy "default-src 'self';";
    }
}
```

**Best Practices**:

- Never commit API keys or other secrets to version control
- Use HTTPS in production to encrypt data in transit
- Implement rate limiting to prevent abuse
- Validate and sanitize all inputs to prevent injection attacks
- Keep dependencies updated to address known security vulnerabilities
- Use role-based access control when available
- Regularly audit system logs for suspicious activity
- Implement proper CORS policies to restrict origin access


---

**Analysis Confidence**: 9.5/10
