# 系统边界接口文档

本文档描述系统的外部调用接口，包括 CLI 命令、API 端点、配置参数和其他边界机制。

## 命令行接口（CLI）

### cortex-mem-cli

**描述**：用于管理记忆和会话的 CLI 工具

**源文件**：`cortex-mem-cli/src/main.rs`

**参数**：

- `config` (PathBuf)：必需 - 配置文件路径
- `tenant` (String)：必需 - 多租户租户标识符
- `verbose` (bool)：可选 - 启用详细日志

**选项**：

- `--config, -c`(PathBuf)：必需 - 配置文件路径
- `--tenant, -t`(String)：必需 - 租户 ID
- `--verbose, -v`(bool)：可选 - 启用详细输出（默认：`false`）

**使用示例**：

```bash
cortex-mem-cli --config /etc/cortex/config.toml --tenant acme add --thread thread-123 --role user --content "Hello"
```

```bash
cortex-mem-cli -c config.toml -t acme search --query "machine learning" --limit 10
```

```bash
cortex-mem-cli --config config.toml --tenant acme session create --thread thread-456 --title "My Session"
```

```bash
cortex-mem-cli --config config.toml --tenant acme list --uri /memories --include-abstracts
```

```bash
cortex-mem-cli --config config.toml --tenant acme stats
```

### cortex-mem-mcp

**描述**：用于通过 stdio 进行记忆操作的 MCP（模型上下文协议）服务器

**源文件**：`cortex-mem-mcp/src/main.rs`

**参数**：

- `config` (PathBuf)：必需 - 配置文件路径
- `tenant` (String)：必需 - 租户标识符

**选项**：

- `--config, -c`(PathBuf)：必需 - 配置文件路径
- `--tenant, -t`(String)：必需 - 租户 ID

**使用示例**：

```bash
cortex-mem-mcp --config /etc/cortex/config.toml --tenant acme
```

### cortex-mem-service

**描述**：用于记忆操作的 HTTP 服务，提供 RESTful API

**源文件**：`cortex-mem-service/src/main.rs`

**参数**：

- `data_dir` (String)：必需 - 持久化的数据目录
- `host` (String)：必需 - 服务器主机地址
- `port` (u16)：必需 - 服务器端口
- `verbose` (bool)：可选 - 启用详细日志

**选项**：

- `--data-dir, -d`(String)：必需 - 数据目录路径
- `--host, -h`(String)：必需 - 绑定的主机地址
- `--port, -p`(u16)：必需 - 监听端口
- `--verbose, -v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cortex-mem-service --data-dir /var/lib/cortex --host 0.0.0.0 --port 8080
```

```bash
cortex-mem-service -d /data -h 127.0.0.1 -p 3000 --verbose
```

### cortex-mem-tars

**描述**：TARS（Talk, Ask, Retrieve, Store）示例应用，带有记忆集成

**源文件**：`examples/cortex-mem-tars/src/main.rs`

**参数**：

- `enhance_memory_saver` (bool)：可选 - 启用记忆保存器增强
- `enable_audio_connect` (bool)：可选 - 启用音频连接功能
- `audio_connect_mode` (String)：可选 - 音频连接模式设置
- `enhance_vector_search` (bool)：可选 - 启用向量搜索增强

**选项**：

- `--enhance-memory-saver`(bool)：可选 - 增强记忆保存器功能（默认：`false`）
- `--enable-audio-connect`(bool)：可选 - 启用音频连接集成（默认：`false`）
- `--audio-connect-mode`(String)：可选 - 音频连接模式（stdio、websocket、sse）（默认：`stdio`）
- `--enhance-vector-search`(bool)：可选 - 增强向量搜索能力（默认：`false`）

**使用示例**：

```bash
cortex-mem-tars --enhance-memory-saver --enable-audio-connect --audio-connect-mode websocket
```

```bash
cortex-mem-tars --enhance-vector-search
```

## API 接口

### GET /api/memory/

**描述**：用于创建、检索、更新和删除具有向量搜索功能的记忆的记忆管理 API

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：查询参数：user_id?, agent_id?, run_id?, actor_id?, memory_type?, limit?, offset?

**响应格式**：JSON: { total: number, memories: Array<{id, content, metadata, created_at, updated_at}> }

### POST /api/memory/search

**描述**：使用向量嵌入的语义相似性搜索记忆

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：JSON: { query: string, user_id?, agent_id?, run_id?, actor_id?, memory_type?, limit?, similarity_threshold? }

**响应格式**：JSON: { total: number, results: Array<{memory: MemoryResponse, score: number}> }

### GET /api/memory/:id

**描述**：通过 ID 检索特定记忆

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：路径参数：id

**响应格式**：JSON: MemoryResponse { id, content, metadata, created_at, updated_at }

### POST /api/memory/

**描述**：创建新的记忆条目

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：JSON: { content: string, metadata?: object }

**响应格式**：JSON: MemoryResponse

### PUT /api/memory/:id

**描述**：更新现有记忆

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：JSON: { content: string }

**响应格式**：JSON: MemoryResponse

### DELETE /api/memory/:id

**描述**：通过 ID 删除记忆

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：路径参数：id

**响应格式**：JSON: { success: boolean }

### POST /api/memory/batch/delete

**描述**：批量删除多个记忆

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：JSON: { ids: string[] }

**响应格式**：JSON: { deleted: number }

### GET /api/memory/stats/summary

**描述**：获取记忆统计摘要

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：无

**响应格式**：JSON: 统计对象

### GET /api/memory/stats/types

**描述**：按类型获取记忆统计

**源文件**：`cortex-mem-insights/src/server/api/memory.ts`

**请求格式**：无

**响应格式**：JSON: 类型分布统计

### POST /api/optimization/

**描述**：触发记忆优化流程

**源文件**：`cortex-mem-insights/src/server/api/optimization.ts`

**请求格式**：JSON: { memory_type?, user_id?, agent_id?, run_id?, actor_id?, similarity_threshold?, dry_run?, verbose?, strategy?, aggressive?, timeout_minutes? }

**响应格式**：JSON: OptimizationJob { jobId, status }

### GET /api/optimization/history

**描述**：获取优化历史

**源文件**：`cortex-mem-insights/src/server/api/optimization.ts`

**请求格式**：查询参数

**响应格式**：JSON: Array<OptimizationRecord>

### GET /api/optimization/statistics

**描述**：获取优化统计

**源文件**：`cortex-mem-insights/src/server/api/optimization.ts`

**请求格式**：无

**响应格式**：JSON: OptimizationStatistics

### POST /api/optimization/analyze

**描述**：分析优化机会

**源文件**：`cortex-mem-insights/src/server/api/optimization.ts`

**请求格式**：JSON: 分析参数

**响应格式**：JSON: AnalysisResult

### GET /api/optimization/:jobId

**描述**：通过 ID 获取优化作业状态

**源文件**：`cortex-mem-insights/src/server/api/optimization.ts`

**请求格式**：路径参数：jobId

**响应格式**：JSON: OptimizationJob

### POST /api/optimization/:jobId/cancel

**描述**：取消优化作业

**源文件**：`cortex-mem-insights/src/server/api/optimization.ts`

**请求格式**：路径参数：jobId

**响应格式**：JSON: { success: boolean }

### POST /api/optimization/cleanup

**描述**：清理旧的优化历史

**源文件**：`cortex-mem-insights/src/server/api/optimization.ts`

**请求格式**：JSON: { maxAgeDays?: number }

**响应格式**：JSON: { cleaned: number }

### GET /api/system/status

**描述**：获取系统状态概览

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：无

**响应格式**：JSON: SystemStatus { status, version, uptime, components }

### GET /api/system/vector-store/status

**描述**：获取向量存储连接状态

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：无

**响应格式**：JSON: { connected: boolean, latency: number, collections: number }

### GET /api/system/llm/status

**描述**：获取 LLM 服务状态

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：无

**响应格式**：JSON: { available: boolean, model: string, queue_size: number }

### GET /api/system/metrics

**描述**：获取系统性能指标

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：无

**响应格式**：JSON: PerformanceMetrics { cpu, memory, requests, latency }

### GET /api/system/info

**描述**：获取系统信息

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：无

**响应格式**：JSON: SystemInfo { version, platform, config }

### GET /api/system/logs

**描述**：获取系统日志

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：查询：level?, limit?, since?

**响应格式**：JSON: Array<LogEntry>

### GET /api/system/resources

**描述**：获取系统资源使用情况

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：无

**响应格式**：JSON: { cpu, memory, disk, network }

### POST /api/system/clear-cache

**描述**：清除系统缓存

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：无

**响应格式**：JSON: { cleared: boolean, bytes: number }

### POST /api/system/restart

**描述**：重启系统服务

**源文件**：`cortex-mem-insights/src/server/api/system.ts`

**请求格式**：JSON: { force?: boolean }

**响应格式**：JSON: { success: boolean, message: string }

### GET /health

**描述**：健康检查端点

**源文件**：`cortex-mem-insights/src/server/index.ts`

**请求格式**：无

**响应格式**：JSON: { status: string, timestamp: string }

### POST /api/memory/store

**描述**：通过 TARS API 存储记忆

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：JSON: StoreMemoryRequest

**响应格式**：JSON: StoreMemoryResponse

### GET /api/memory/retrieve

**描述**：通过 TARS API 检索记忆

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：查询：{ query?, speaker_type?, limit? }

**响应格式**：JSON: RetrieveMemoryResponse

### GET /api/memory/list

**描述**：通过 TARS API 列出记忆

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：查询：{ speaker_type?, limit?, offset? }

**响应格式**：JSON: ListMemoryResponse

### GET /api/memory/health

**描述**：记忆服务健康检查

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：无

**响应格式**：JSON: { status: string }

### GET /filesystem/list

**描述**：列出目录内容

**源文件**：`cortex-mem-service/src/handlers/filesystem.rs`

**请求格式**：查询：{ uri: string }

**响应格式**：JSON: ApiResponse<Array<FileEntryResponse>>

### GET /filesystem/read/:path

**描述**：读取文件内容

**源文件**：`cortex-mem-service/src/handlers/filesystem.rs`

**请求格式**：路径参数：path（URL 编码）

**响应格式**：JSON: ApiResponse<string>

### GET /sessions/

**描述**：列出所有会话

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：无

**响应格式**：JSON: ApiResponse<Array<SessionResponse>>

### POST /sessions/

**描述**：创建新会话

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：JSON: { thread_id?, title?, metadata? }

**响应格式**：JSON: ApiResponse<SessionResponse>

### POST /sessions/:thread_id/messages

**描述**：向会话添加消息

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：JSON: { role: string, content: string, metadata? }

**响应格式**：JSON: ApiResponse<string>

### POST /sessions/:thread_id/close

**描述**：关闭会话

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：路径参数：thread_id

**响应格式**：JSON: ApiResponse<SessionResponse>

### POST /search/

**描述**：使用语义相似性搜索记忆

**源文件**：`cortex-mem-service/src/handlers/search.rs`

**请求格式**：JSON: { query: string, thread?, limit?, min_score?, scope? }

**响应格式**：JSON: ApiResponse<Array<SearchResultResponse>>

### POST /automation/extract/:thread_id

**描述**：为线程触发提取

**源文件**：`cortex-mem-service/src/handlers/automation.rs`

**请求格式**：JSON: { auto_save?: boolean }

**响应格式**：JSON: ApiResponse<ExtractionResult>

### POST /automation/index/:thread_id

**描述**：为线程触发索引

**源文件**：`cortex-mem-service/src/handlers/automation.rs`

**请求格式**：路径参数：thread_id

**响应格式**：JSON: ApiResponse<IndexResult>

### POST /automation/index-all

**描述**：为所有线程触发索引

**源文件**：`cortex-mem-service/src/handlers/automation.rs`

**请求格式**：无

**响应格式**：JSON: ApiResponse<IndexAllResult>

### POST /embed (外部)

**描述**：用于文本向量化的嵌入服务

**源文件**：`cortex-mem-core/src/embedding/client.rs`

**请求格式**：JSON: { text: string } 或 { texts: string[] }

**响应格式**：JSON: { embedding: number[] } 或 { embeddings: number[][] }

### CLI 服务器启动

**描述**：使用自定义配置启动 API 服务器

**源文件**：`cortex-mem-service/src/main.rs`

**请求格式**：CLI 参数：data_dir, host, port, verbose

**响应格式**：运行中的服务器

## 路由器路由

### /monitor

**描述**：用于监控系统指标、性能和健康状态的 SvelteKit 页面

**源文件**：`cortex-mem-insights/src/routes/monitor/+page.svelte`

**参数**：

- `currentPath` (string)：用于导航高亮的当前 URL 路径名

### /

**描述**：带有导航和多语言支持的 SvelteKit 根布局

**源文件**：`cortex-mem-insights/src/routes/+layout.svelte`

**参数**：

- `currentPath` (string)：来自 $page 商店的当前页面 URL 路径名

### /

**描述**：用于客户端渲染的 SvelteKit 布局配置

**源文件**：`cortex-mem-insights/src/routes/+layout.ts`

### /health

**描述**：用于服务可用性的健康检查端点

**源文件**：`cortex-mem-insights/src/server/index.ts`

### /api/memory/*

**描述**：用于记忆管理操作的 API 路由

**源文件**：`cortex-mem-insights/src/server/index.ts`

**参数**：

- `*` (string)：记忆操作端点路径

### /api/optimization/*

**描述**：用于记忆优化操作的 API 路由

**源文件**：`cortex-mem-insights/src/server/index.ts`

**参数**：

- `*` (string)：优化操作端点路径

### /api/system/*

**描述**：用于系统管理的 API 路由

**源文件**：`cortex-mem-insights/src/server/index.ts`

**参数**：

- `*` (string)：系统操作端点路径

### /filesystem/:action/:path?

**描述**：用于目录和文件操作的文件系统路由

**源文件**：`cortex-mem-service/src/routes/filesystem.rs`

**参数**：

- `action` (string)：操作类型（list 或 read）
- `path` (string)：文件或目录路径

### /automation/:action/:thread_id?

**描述**：用于提取和索引的自动化路由

**源文件**：`cortex-mem-service/src/routes/automation.rs`

**参数**：

- `action` (string)：操作类型（extract、index 或 index-all）
- `thread_id` (string)：提取/索引的线程 ID

### /sessions/:thread_id/:subaction?

**描述**：会话管理路由

**源文件**：`cortex-mem-service/src/routes/sessions.rs`

**参数**：

- `thread_id` (string)：特定会话的线程 ID
- `subaction` (string)：子操作（messages、close）

### /search/

**描述**：用于语义记忆查询的搜索端点

**源文件**：`cortex-mem-service/src/routes/search.rs`

### /api/:module/*

**描述**：组合所有模块路由的 API 路由器

**源文件**：`cortex-mem-service/src/routes/mod.rs`

**参数**：

- `module` (string)：模块路径（filesystem、sessions、search、automation）

## 集成建议

### Web 仪表板集成

与 Cortex Memory Insights Web Dashboard 集成

**示例代码**：

```
import { api } from '@cortex-mem/insights-client';

// 测试连接
const connectionTest = await api.testConnection('http://localhost:8000');
console.log('Connection status:', connectionTest);

// 搜索记忆
const results = await api.memory.search({
  query: 'project requirements',
  memory_type: 'conversation',
  limit: 10,
  similarity_threshold: 0.7
});

// 创建记忆
const memory = await api.memory.create({
  content: 'Important project decision: Use Rust for backend',
  metadata: { project: 'cortex-mem', priority: 'high' }
});

// 优化记忆
const optimizationJob = await api.optimization.optimize({
  strategy: 'deduplication',
  similarity_threshold: 0.95,
  dry_run: false
});

// 监控优化
const status = await api.optimization.getStatus(optimizationJob.jobId);

// 系统监控
const metrics = await api.system.metrics();
const systemStatus = await api.system.status();
```

**最佳实践**：

- 始终为生产部署明确配置 CORS 来源
- 为 LLM 和向量存储客户端使用连接池
- 使用 onError 钩子实现适当的错误处理
- 启用请求/响应日志的跟踪
- 使用环境变量进行敏感配置（API 密钥）
- 为嵌入服务调用实现重试逻辑
- 为批量记忆操作使用批量操作
- 监控内存使用并实施清理作业
- 使用相似性阈值过滤低质量搜索结果
- 实现优雅的关闭处理器

### MCP 协议集成

用于 AI 助手的模型上下文协议（MCP）集成

**示例代码**：

```
// 初始化 MCP 服务
use cortex_mem_mcp::MemoryMcpService;
use cortex_mem_core::{Config, LLMClientImpl, MemoryOperations};

#[tokio::main]
async fn main() -> Result<()> {
    let config = Config::load("/etc/cortex/config.toml")?;
    let _ = tracing_subscriber::fmt::init();
    
    let llm_client = LLMClientImpl::new(&config.llm).await?;
    let memory_ops = MemoryOperations::new(&config, &llm_client).await?;
    
    let mcp_service = MemoryMcpService::new(memory_ops);
    mcp_service.serve_stdio().await?;
    
    Ok(())
}
```

**最佳实践**：

- 在 MemoryOperations 之前初始化 LLM 客户端
- 使用 TOML 格式存储配置
- 为多租户场景使用租户隔离
- 为 MCP 操作实现适当的错误处理
- 启用调试跟踪
- 使用 stdio 传输以符合 MCP 协议

### Rust 服务路由器集成

带有模块化路由的 Rust Axum 服务集成

**示例代码**：

```
use axum::{Router, routing::{get, post}};
use std::sync::Arc;

// 构建模块化路由器
let api_routes = Router::new()
    .nest("/filesystem", filesystem::routes())
    .nest("/sessions", sessions::routes())
    .nest("/search", search::routes())
    .nest("/automation", automation::routes());

let app = Router::new()
    .route("/health", get(health_check))
    .nest("/api", api_routes)
    .with_state(Arc::new(app_state));

// 分层搜索实现
async fn search_layered(
    state: &AppState,
    query: &str,
    thread: Option<&str>,
    limit: usize,
    min_score: f32
) -> Result<Vec<SearchResultResponse>> {
    // 第一轮：语义搜索
    let results = state.vector_store.search(
        &embedding,
        limit * 2,
        min_score
    ).await?;
    
    // 第二轮：按相关性重新排名
    let reranked = rerank_results(results, query).await?;
    
    Ok(reranked.into_iter().take(limit).collect())
}
```

**最佳实践**：

- 使用服务路由器进行模块化 API 设计
- 使用 Arc<AppState> 实现适当的状态管理
- 为复杂查询使用分层搜索
- 为服务监控实现健康检查
- 一致地使用 JSON API 响应
- 正确处理文件系统路由的文件路径编码
- 为大型数据集使用批量索引

### Bun/Elysia TypeScript 服务器

用于 Insights API 的 Bun/Elysia TypeScript 服务器

**示例代码**：

```
import { Elysia } from 'elysia';
import { cors } from '@elysiajs/cors';
import { memoryRoutes } from './api/memory';
import { optimizationRoutes } from './api/optimization';
import { systemRoutes } from './api/system';

const app = new Elysia()
  .use(cors({
    origin: ['http://localhost:5173', 'http://localhost:8000'],
    credentials: true
  }))
  .onError(({ code, error, set }) => {
    console.error(`[${code}]`, error);
    set.status = 500;
    return { error: error.message, code };
  })
  .get('/health', () => ({ status: 'ok', timestamp: new Date().toISOString() }))
  .group('/api/memory', (app) => app.use(memoryRoutes))
  .group('/api/optimization', (app) => app.use(optimizationRoutes))
  .group('/api/system', (app) => app.use(systemRoutes))
  .listen(3000);

console.log(`Server running at ${app.server?.hostname}:${app.server?.port}`);
```

**最佳实践**：

- 为基于 Bun 的高性能服务器使用 Elysia
- 为前端集成实现 CORS
- 使用 onError 钩子实现结构化日志
- 实现优雅的错误响应
- 使用 TypeScript 以获得类型安全
- 按领域组织路由（memory、optimization、system）

### TARS 应用模板

TARS（Talk, Ask, Retrieve, Store）应用集成模式

**示例代码**：

```
use cortex_mem_tars::{ConfigManager, Infrastructure, App};

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();
    
    // 配置
    let config_manager = ConfigManager::new()?;
    init_logger();
    
    // 创建机器人
    let bots = create_default_bots(&config_manager);
    
    // 基础设施
    let infrastructure = Infrastructure::new(
        &config_manager,
        args.enhance_memory_saver,
        args.enable_audio_connect,
        &args.audio_connect_mode,
        args.enhance_vector_search
    ).await?;
    
    // 应用
    let app = App::new(bots, infrastructure)?;
    
    // 检查服务状态
    app.check_service_status().await?;
    
    // 运行和清理
    app.run().await?;
    
    // 退出时有条件保存
    if args.enhance_memory_saver {
        app.on_exit().await?;
    }
    
    Ok(())
}
```

**最佳实践**：

- 在其他组件之前初始化 ConfigManager
- 退出时使用有条件记忆保存
- 为外部集成启动 API 服务器
- 操作前检查服务状态
- 使用适当的日志初始化
- 使用 on_exit 处理器实现优雅关闭

### 自动化索引集成

对话线程和消息的自动化索引

**示例代码**：

```
use cortex_mem_core::automation::{AutoIndexer, IndexerConfig};

// 配置
let config = IndexerConfig {
    auto_index: true,
    batch_size: 100,
    async_index: true,
};

// 初始化索引器
let indexer = AutoIndexer::new(
    Arc::new(filesystem),
    Arc::new(embedding_client),
    Arc::new(vector_store),
    config
);

// 带进度的索引线程
indexer.index_thread_with_progress(
    &thread_id,
    |progress| println!("Indexed: {:.1}%", progress * 100.0)
).await?;

// 递归收集消息
let messages = indexer.collect_messages_recursive(&thread_uri).await?;

// 批量索引
indexer.index_message_batch(&messages).await?;
```

**最佳实践**：

- 为批处理使用 AutoIndexer
- 为性能启用异步索引
- 计算内容哈希以避免重复索引
- 为长时间运行的操作使用进度回调
- 解析 markdown 内容以进行结构化提取
- 根据嵌入服务容量配置批量大小

---

**分析置信度**：9.0/10
