# 系统边界接口文档

本文档描述系统的外部调用接口，包括 CLI 命令、API 端点、配置参数和其他边界机制。

## 命令行接口（CLI）

### cortex-mem-cli

**描述**：用于管理记忆和会话的 CLI 工具

**源文件**：`cortex-mem-cli/src/main.rs`

**参数**：

- `config` (PathBuf)：必需 - 配置文件路径
- `tenant` (String)：必需 - 多租户租户标识符
- `verbose` (bool)：可选 - 启用详细日志

**选项**：

- `--config, -c`(PathBuf)：必需 - 配置文件路径
- `--tenant, -t`(String)：必需 - 租户 ID
- `--verbose, -v`(bool)：可选 - 启用详细输出（默认：`false`）

**使用示例**：

```bash
cortex-mem-cli --config /etc/cortex/config.toml --tenant acme add --thread thread-123 --role user --content "Hello"
```

```bash
cortex-mem-cli -c config.toml -t acme search --query "machine learning" --limit 10
```

```bash
cortex-mem-cli --config config.toml --tenant acme session create --thread thread-456 --title "My Session"
```

```bash
cortex-mem-cli --config config.toml --tenant acme list --uri /memories --include-abstracts
```

```bash
cortex-mem-cli --config config.toml --tenant acme stats
```

### cortex-mem-mcp

**描述**：用于通过 stdio 进行记忆操作的 MCP（模型上下文协议）服务器

**源文件**：`cortex-mem-mcp/src/main.rs`

**参数**：

- `config` (PathBuf)：必需 - 配置文件路径
- `tenant` (String)：必需 - 租户标识符

**选项**：

- `--config, -c`(PathBuf)：必需 - 配置文件路径
- `--tenant, -t`(String)：必需 - 租户 ID

**使用示例**：

```bash
cortex-mem-mcp --config /etc/cortex/config.toml --tenant acme
```

### cortex-mem-service

**描述**：用于记忆操作的 HTTP 服务，提供 RESTful API

**源文件**：`cortex-mem-service/src/main.rs`

**参数**：

- `data_dir` (String)：必需 - 持久化的数据目录
- `host` (String)：必需 - 服务器主机地址
- `port` (u16)：必需 - 服务器端口
- `verbose` (bool)：可选 - 启用详细日志

**选项**：

- `--data-dir, -d`(String)：必需 - 数据目录路径
- `--host, -h`(String)：必需 - 绑定的主机地址
- `--port, -p`(u16)：必需 - 监听端口
- `--verbose, -v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cortex-mem-service --data-dir /var/lib/cortex --host 0.0.0.0 --port 8085
```

```bash
cortex-mem-service -d /data -h 127.0.0.1 -p 3000 --verbose
```

### cortex-mem-tars

**描述**：TARS（Talk, Ask, Retrieve, Store）示例应用，带有记忆集成

**源文件**：`examples/cortex-mem-tars/src/main.rs`

**参数**：

- `enhance_memory_saver` (bool)：可选 - 启用记忆保存器增强
- `enable_audio_connect` (bool)：可选 - 启用音频连接功能
- `audio_connect_mode` (String)：可选 - 音频连接模式设置
- `enhance_vector_search` (bool)：可选 - 启用向量搜索增强

**选项**：

- `--enhance-memory-saver`(bool)：可选 - 增强记忆保存器功能（默认：`false`）
- `--enable-audio-connect`(bool)：可选 - 启用音频连接集成（默认：`false`）
- `--audio-connect-mode`(String)：可选 - 音频连接模式（stdio、websocket、sse）（默认：`stdio`）
- `--enhance-vector-search`(bool)：可选 - 增强向量搜索能力（默认：`false`）

**使用示例**：

```bash
cortex-mem-tars --enhance-memory-saver --enable-audio-connect --audio-connect-mode websocket
```

```bash
cortex-mem-tars --enhance-vector-search
```

## API 接口

### 健康检查端点

#### GET /health

**描述**：服务可用性的健康检查端点

**源文件**：`cortex-mem-service/src/handlers/health.rs`

**请求格式**：无

**响应格式**：JSON: `{ status: string, service: string, version: string, llm_available: boolean }`

### 租户端点

#### GET /api/v2/tenants/tenants

**描述**：列出所有可用租户

**源文件**：`cortex-mem-service/src/handlers/tenants.rs`

**请求格式**：无

**响应格式**：JSON: `ApiResponse<string[]>`

#### POST /api/v2/tenants/tenants/switch

**描述**：切换活动租户上下文

**源文件**：`cortex-mem-service/src/handlers/tenants.rs`

**请求格式**：JSON: `{ tenant_id: string }`

**响应格式**：JSON: `ApiResponse<string>`

### 文件系统端点

#### GET /api/v2/filesystem/list

**描述**：列出目录内容

**源文件**：`cortex-mem-service/src/handlers/filesystem.rs`

**请求格式**：查询：`{ uri: string }`

**响应格式**：JSON: `ApiResponse<FileEntryResponse[]>`

**FileEntryResponse**：
```typescript
{
  uri: string;
  name: string;
  is_directory: boolean;
  size: number;
  modified: string;
}
```

#### GET /api/v2/filesystem/read/:path

**描述**：读取文件内容

**源文件**：`cortex-mem-service/src/handlers/filesystem.rs`

**请求格式**：路径参数：`path`（URL 编码，支持 `cortex://` URI）

**响应格式**：JSON: `ApiResponse<string>`

#### POST /api/v2/filesystem/write

**描述**：写入文件内容

**源文件**：`cortex-mem-service/src/handlers/filesystem.rs`

**请求格式**：JSON: `{ path: string, content: string }`

**响应格式**：JSON: `ApiResponse<string>`

#### GET /api/v2/filesystem/stats

**描述**：获取目录统计

**源文件**：`cortex-mem-service/src/handlers/filesystem.rs`

**请求格式**：查询：`{ uri: string }`

**响应格式**：JSON: `ApiResponse<{ file_count: number, total_size: number }>`

### 会话端点

#### GET /api/v2/sessions

**描述**：列出所有会话

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：无

**响应格式**：JSON: `ApiResponse<SessionResponse[]>`

**SessionResponse**：
```typescript
{
  thread_id: string;
  status: string;
  message_count: number;
}
```

#### POST /api/v2/sessions

**描述**：创建新会话

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：JSON: `{ thread_id?: string, title?: string, metadata?: object }`

**响应格式**：JSON: `ApiResponse<SessionResponse>`

#### POST /api/v2/sessions/:thread_id/messages

**描述**：向会话添加消息

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：JSON: `{ role: string, content: string, metadata?: object }`

**响应格式**：JSON: `ApiResponse<string>`（消息 ID）

#### POST /api/v2/sessions/:thread_id/close

**描述**：关闭会话并触发提取

**源文件**：`cortex-mem-service/src/handlers/sessions.rs`

**请求格式**：路径参数：`thread_id`

**响应格式**：JSON: `ApiResponse<SessionResponse>`

### 搜索端点

#### POST /api/v2/search

**描述**：使用语义相似性搜索记忆

**源文件**：`cortex-mem-service/src/handlers/search.rs`

**请求格式**：JSON：
```typescript
{
  query: string;
  thread?: string;
  limit?: number;
  min_score?: number;
  scope?: string;
}
```

**响应格式**：JSON: `ApiResponse<SearchResultResponse[]>`

**SearchResultResponse**：
```typescript
{
  uri: string;
  score: number;
  snippet: string;
  content?: string;
  source: string;
}
```

### 自动化端点

#### POST /api/v2/automation/extract/:thread_id

**描述**：为线程触发提取

**源文件**：`cortex-mem-service/src/handlers/automation.rs`

**请求格式**：JSON: `{ auto_save?: boolean }`

**响应格式**：JSON: `ApiResponse<ExtractionResult>`

#### POST /api/v2/automation/index/:thread_id

**描述**：为线程触发索引

**源文件**：`cortex-mem-service/src/handlers/automation.rs`

**请求格式**：路径参数：`thread_id`

**响应格式**：JSON: `ApiResponse<IndexResult>`

#### POST /api/v2/automation/index-all

**描述**：为所有线程触发索引

**源文件**：`cortex-mem-service/src/handlers/automation.rs`

**请求格式**：无

**响应格式**：JSON: `ApiResponse<IndexAllResult>`

### TARS API 端点

#### POST /api/memory/store

**描述**：通过 TARS API 存储记忆

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：JSON: `StoreMemoryRequest`

**响应格式**：JSON: `StoreMemoryResponse`

#### GET /api/memory/retrieve

**描述**：通过 TARS API 检索记忆

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：查询：`{ query?: string, speaker_type?: string, limit?: number }`

**响应格式**：JSON: `RetrieveMemoryResponse`

#### GET /api/memory/list

**描述**：通过 TARS API 列出记忆

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：查询：`{ speaker_type?: string, limit?: number, offset?: number }`

**响应格式**：JSON: `ListMemoryResponse`

#### GET /api/memory/health

**描述**：记忆服务健康检查

**源文件**：`examples/cortex-mem-tars/src/api_server.rs`

**请求格式**：无

**响应格式**：JSON: `{ status: string }`

### 外部服务端点

#### POST /embed（外部）

**描述**：用于文本向量化的嵌入服务

**源文件**：`cortex-mem-core/src/embedding/client.rs`

**请求格式**：JSON: `{ text: string }` 或 `{ texts: string[] }`

**响应格式**：JSON: `{ embedding: number[] }` 或 `{ embeddings: number[][] }`

## 路由器路由

### cortex-mem-service 路由

**源文件**：`cortex-mem-service/src/routes/mod.rs`

```
/health                              → 健康检查端点
/api/v2/filesystem/list              → 列出目录内容
/api/v2/filesystem/read/*path        → 读取文件内容
/api/v2/filesystem/write             → 写入文件内容
/api/v2/filesystem/stats             → 获取目录统计
/api/v2/sessions                     → 列出/创建会话
/api/v2/sessions/:thread_id/messages → 向会话添加消息
/api/v2/sessions/:thread_id/close    → 关闭会话
/api/v2/search                       → 语义搜索
/api/v2/automation/extract/:thread_id → 触发提取
/api/v2/automation/index/:thread_id  → 触发索引
/api/v2/automation/index-all         → 索引所有线程
/api/v2/tenants/tenants              → 列出租户
/api/v2/tenants/tenants/switch       → 切换租户
```

### cortex-mem-insights 路由

**源文件**：`cortex-mem-insights/src/App.svelte`

客户端路由（手动路由，非 SvelteKit 文件系统路由）：

```
/              → 仪表板页面（租户概览、健康状态）
/memories      → 记忆页面（cortex:// URI 文件浏览器）
/search        → 搜索页面（语义搜索界面）
```

## 通用响应格式

`cortex-mem-service` 的所有 API 响应遵循一致的包装格式：

```typescript
interface ApiResponse<T> {
  success: boolean;
  data: T | null;
  error: string | null;
  timestamp: string;
}
```

## 集成建议

### Web 仪表板集成

与 Cortex Memory Insights Web Dashboard 集成

**示例代码**：

```typescript
import apiClient from './api';

// 健康检查
const health = await apiClient.getHealth();
console.log('服务状态:', health.status);
console.log('LLM 可用:', health.llm_available);

// 列出租户
const tenants = await apiClient.listTenants();
console.log('可用租户:', tenants);

// 切换租户
await apiClient.switchTenant('acme');

// 浏览记忆
const files = await apiClient.listDirectory('cortex://memories');
for (const file of files) {
  if (!file.is_directory) {
    const content = await apiClient.readFile(file.uri);
    console.log(`${file.name}: ${content}`);
  }
}

// 搜索记忆
const results = await apiClient.search('机器学习', 'all', 10);
for (const result of results) {
  console.log(`[${result.score.toFixed(2)}] ${result.snippet}`);
}

// 获取目录统计
const stats = await apiClient.getDirectoryStats('cortex://memories');
console.log(`总文件数: ${stats.file_count}, 大小: ${stats.total_size} 字节`);
```

**最佳实践**：

- 始终使用 try-catch 块处理 API 错误
- 为多租户场景使用租户上下文
- 实现加载状态以获得更好的用户体验
- 缓存租户信息以减少 API 调用
- 对文件系统路径使用 URL 编码

### MCP 协议集成

用于 AI 助手的模型上下文协议（MCP）集成

**示例代码**：

```rust
use cortex_mem_mcp::MemoryMcpService;
use cortex_mem_core::{Config, LLMClientImpl, MemoryOperations};

#[tokio::main]
async fn main() -> Result<()> {
    let config = Config::load("/etc/cortex/config.toml")?;
    let _ = tracing_subscriber::fmt::init();
    
    let llm_client = LLMClientImpl::new(&config.llm).await?;
    let memory_ops = MemoryOperations::new(&config, &llm_client).await?;
    
    let mcp_service = MemoryMcpService::new(memory_ops);
    mcp_service.serve_stdio().await?;
    
    Ok(())
}
```

**最佳实践**：

- 在 MemoryOperations 之前初始化 LLM 客户端
- 使用 TOML 格式存储配置
- 为多租户场景使用租户隔离
- 为 MCP 操作实现适当的错误处理
- 启用调试跟踪
- 使用 stdio 传输以符合 MCP 协议

### Rust 服务路由器集成

带有模块化路由的 Rust Axum 服务集成

**示例代码**：

```rust
use axum::{Router, routing::{get, post}};
use std::sync::Arc;

// 构建模块化路由器
let api_routes = Router::new()
    .nest("/filesystem", filesystem::routes())
    .nest("/sessions", sessions::routes())
    .nest("/search", search::routes())
    .nest("/automation", automation::routes())
    .nest("/tenants", tenants::routes());

let app = Router::new()
    .route("/health", get(health_check))
    .nest("/api/v2", api_routes)
    .layer(CorsLayer::permissive())
    .layer(TraceLayer::new_for_http())
    .with_state(Arc::new(app_state));

// 启动服务器
let addr = SocketAddr::from(([127, 0, 0, 1], 8085));
let listener = tokio::net::TcpListener::bind(addr).await?;
axum::serve(listener, app).await?;
```

**最佳实践**：

- 使用服务路由器进行模块化 API 设计
- 使用 Arc<AppState> 实现适当的状态管理
- 为复杂查询使用分层搜索
- 为服务监控实现健康检查
- 一致地使用 JSON API 响应
- 正确处理文件系统路由的文件路径编码
- 为大型数据集使用批量索引

### TARS 应用模板

TARS（Talk, Ask, Retrieve, Store）应用集成模式

**示例代码**：

```rust
use cortex_mem_tars::{ConfigManager, Infrastructure, App};

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();
    
    // 配置
    let config_manager = ConfigManager::new()?;
    init_logger();
    
    // 创建机器人
    let bots = create_default_bots(&config_manager);
    
    // 基础设施
    let infrastructure = Infrastructure::new(
        &config_manager,
        args.enhance_memory_saver,
        args.enable_audio_connect,
        &args.audio_connect_mode,
        args.enhance_vector_search
    ).await?;
    
    // 应用
    let app = App::new(bots, infrastructure)?;
    
    // 检查服务状态
    app.check_service_status().await?;
    
    // 运行和清理
    app.run().await?;
    
    // 退出时有条件保存
    if args.enhance_memory_saver {
        app.on_exit().await?;
    }
    
    Ok(())
}
```

**最佳实践**：

- 在其他组件之前初始化 ConfigManager
- 退出时使用有条件记忆保存
- 为外部集成启动 API 服务器
- 操作前检查服务状态
- 使用适当的日志初始化
- 使用 on_exit 处理器实现优雅关闭

### 自动化索引集成

对话线程和消息的自动化索引

**示例代码**：

```rust
use cortex_mem_core::automation::{AutoIndexer, IndexerConfig};

// 配置
let config = IndexerConfig {
    auto_index: true,
    batch_size: 100,
    async_index: true,
};

// 初始化索引器
let indexer = AutoIndexer::new(
    Arc::new(filesystem),
    Arc::new(embedding_client),
    Arc::new(vector_store),
    config
);

// 带进度的索引线程
indexer.index_thread_with_progress(
    &thread_id,
    |progress| println!("已索引: {:.1}%", progress * 100.0)
).await?;

// 递归收集消息
let messages = indexer.collect_messages_recursive(&thread_uri).await?;

// 批量索引
indexer.index_message_batch(&messages).await?;
```

**最佳实践**：

- 为批处理使用 AutoIndexer
- 为性能启用异步索引
- 计算内容哈希以避免重复索引
- 为长时间运行的操作使用进度回调
- 解析 markdown 内容以进行结构化提取
- 根据嵌入服务容量配置批量大小

---

**文档版本**：2.0  
**最后更新**：2026-02-18  
**分析置信度**：9.0/10