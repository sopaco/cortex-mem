**技术文档：接口层领域**

**系统**：Cortex-Mem  
**版本**：1.0  
**最后更新**：2026-02-17 16:46:44 (UTC)

---

## 1. 执行摘要

**接口层领域**作为 Cortex-Mem 记忆管理系统的统一访问网关，实现**多协议适配器架构**，通过三种不同的交互模式公开核心记忆能力。该领域将外部请求转换为内部领域操作，同时在传输关注点和业务逻辑之间保持严格分离。

该领域实现三种主要接口实现：
1. **命令行接口（CLI）** – 用于脚本化、自动化和开发者工作流
2. **REST API 服务** – 用于服务集成和第三方应用连接
3. **模型上下文协议（MCP）服务器** – 用于 AI 助手和代理集成

通过将核心记忆操作复杂性抽象到协议特定适配器之后，接口层支持跨不同用户角色和集成场景对语义存储、向量搜索、会话管理和自动化提取能力的一致访问。

---

## 2. 架构定位

### 2.1 六边形架构上下文

在 Cortex-Mem 架构中，接口层领域占据**接口适配器**层（遵循六边形/清洁架构原则）：

```
┌─────────────────────────────────────────────────────────────┐
│                    接口层领域                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │     CLI      │  │  REST API    │  │ MCP 服务器   │      │
│  │  (cortex-   │  │  (cortex-   │  │  (cortex-   │      │
│  │   mem-cli)   │  │ mem-service) │  │   mem-mcp)   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  核心领域（记忆操作）                          │
└─────────────────────────────────────────────────────────────┘
```

**依赖规则合规性：** 所有接口实现向内依赖核心领域（cortex-mem-core 和 cortex-mem-tools）和配置领域（cortex-mem-config），从不反向。这确保领域逻辑与传输和协议关注点保持隔离。

### 2.2 组件拓扑

该领域遵循分层的内部架构：

**传输和协议层**
- **Clap 解析器**（CLI）：基于派生的参数解析和验证
- **Axum 路由器**（REST）：HTTP 路由、中间件和请求调度
- **RMCP 框架**（MCP）：协议处理和工具路由

**应用层**
- **命令调度**：CLI 子命令路由（add/search/list/get/delete/session/stats）
- **请求处理器**：按功能区域组织的 REST 端点处理器
- **工具路由器**：MCP 工具注册和执行路由

**核心服务集成**
- **共享状态**：Arc<MemoryOperations> 提供对核心能力的线程安全访问
- **配置**：基于 TOML 的设置，带环境变量覆盖
- **可选组件**：LLM、Qdrant 或嵌入服务不可用时的优雅降级

---

## 3. 组件规格

### 3.1 CLI 应用（cortex-mem-cli）

**技术栈：** Rust，clap（派生宏），colored（终端样式）

CLI 通过带全局选项和彩色输出指示器的命令-子命令模式提供记忆操作的交互和脚本化访问。

**命令结构：**
```bash
cortex-mem [GLOBAL_OPTIONS] <SUBCOMMAND> [SUBCOMMAND_OPTIONS]

全局选项：
  -c, --config <PATH>    配置文件路径
  -t, --tenant <ID>      多租户租户标识符
  -v, --verbose          启用详细输出
```

**子命令：**

| 命令 | 描述 | 关键选项 |
|---------|-------------|-------------|
| add | 存储新记忆条目 | -t, --thread <ID>、-r, --role <ROLE>、content 位置参数 |
| search | 语义向量搜索 | -l, --limit <N>、-s, --min-score <FLOAT>、query 位置参数 |
| list | 枚举记忆条目 | -u, --uri <URI>、--include-abstracts |
| get | 检索特定记忆 | URI 位置参数 |
| delete | 删除记忆条目 | URI 位置参数 |
| session | 会话生命周期管理 | create、close、list 子命令 |
| stats | 显示系统统计 | --format <json\|table> |

**实现模式：**
- 模块化命令结构在 src/commands/ 下，带独立处理器
- 初始化序列：参数解析 → 配置加载 → LLM 客户端设置 → MemoryOperations 初始化
- 通过 anyhow 进行人体工程学错误传播的错误处理
- 带 emoji 指示器的彩色输出用于状态可视化

**使用示例：**
```bash
# 存储带会话上下文的记忆
cortex-mem add -t thread-abc123 "User prefers dark mode interfaces" -r user

# 带相关性阈值的语义搜索
cortex-mem search "dark mode preferences" --limit 5 --min-score 0.75

# 列出用户维度中的所有记忆
cortex-mem list -u cortex://user/default/memories
```

### 3.2 REST API 服务（cortex-mem-service）

**技术栈：** Rust，axum web 框架，tower-http（中间件），serde（序列化）

REST API 提供基于 HTTP 的记忆操作访问，实现路由、处理和状态管理之间清晰分离的分层架构。

**架构层：**
```
src/
├── main.rs          # 服务器初始化和启动
├── state.rs         # AppState 定义和共享资源
├── error.rs         # AppError 枚举和 IntoResponse 实现
├── models.rs        # 请求/响应 DTO
├── routes/          # 路由定义和路径挂载
│   ├── mod.rs       # 路由器组合
│   ├── filesystem.rs # 文件操作端点
│   ├── sessions.rs  # 会话管理端点
│   ├── search.rs    # 语义搜索端点
│   └── automation.rs # 后台处理端点
└── handlers/        # 业务逻辑实现
    ├── mod.rs
    ├── filesystem.rs
    ├── sessions.rs
    ├── search.rs
    ├── automation.rs
    └── health.rs    # 健康检查端点
```

**端点规格：**

| 方法 | 路径 | 描述 | 请求体 | 响应 |
|--------|------|-------------|--------------|----------|
| GET | /health | 服务健康检查 | - | {"status": "healthy"} |
| GET | /api/v2/filesystem/list | 列出目录内容 | 查询：?uri=cortex://... | 目录列表 JSON |
| GET | /api/v2/filesystem/read/{path} | 读取文件内容 | - | 文件内容或错误 |
| POST | /api/v2/sessions | 创建新会话 | {"thread_id": "..."} | 会话元数据 |
| GET | /api/v2/sessions | 列出所有会话 | 查询过滤器 | 会话数组 |
| POST | /api/v2/sessions/{thread_id}/messages | 追加消息 | {"role": "...", "content": "..."} | 消息确认 |
| POST | /api/v2/sessions/{thread_id}/close | 关闭会话 | 可选元数据 | 关闭确认 |
| POST | /api/v2/search | 语义向量搜索 | {"query": "...", "limit": 5, "min_score": 0.7} | 搜索结果数组 |
| POST | /api/v2/automation/extract/{thread_id} | 触发记忆提取 | - | 提取统计 |
| POST | /api/v2/automation/index/{thread_id} | 索引会话到向量数据库 | - | 索引统计 |
| POST | /api/v2/automation/index-all | 索引所有线程 | - | 批量统计 |

**中间件栈：**
- **CORS**：Web 仪表板集成的跨域请求支持
- **跟踪**：通过 tower-http 的请求日志和可观察性
- **压缩**：大型记忆有效负载的响应压缩

**状态管理：**
```rust
pub struct AppState {
    pub memory_ops: Arc<MemoryOperations>,
    pub config: Config,
    // 带优雅降级的可选组件
    pub llm_client: Option<Arc<dyn LlmClient>>,
    pub vector_store: Option<Arc<dyn VectorStore>>,
}
```

**错误处理：**
自定义 AppError 枚举实现 axum::response::IntoResponse，将领域错误映射到适当的 HTTP 状态码（400 Bad Request、404 Not Found、500 Internal Server Error），带结构化 JSON 错误体：
```json
{
  "error": "Memory not found for URI: cortex://user/default/memories/abc123",
  "status": 404
}
```

### 3.3 MCP 服务器（cortex-mem-mcp）

**技术栈：** Rust，rmcp 框架，过程宏

模型上下文协议（MCP）服务器使 AI 助手能够与 Cortex-Mem 作为工具提供商集成，通过 stdio 传输公开记忆操作。

**工具注册：**
服务器通过过程宏（#[tool]、#[tool_router]）暴露六个主要工具：

| 工具名称 | 描述 | 参数 |
|-----------|-------------|------------|
| store_memory | 将消息持久化到记忆 | content (string)、thread_id (string)、role (string) |
| query_memory | 语义搜索 | query (string)、scope (string)、limit (int) |
| list_memories | 枚举条目 | uri (string)、limit (int)、include_abstracts (bool) |
| get_memory | 检索特定条目 | uri (string) |
| delete_memory | 删除条目 | uri (string) |
| get_abstract | 获取 L0 摘要 | uri (string) |

**协议实现：**
- **传输**：stdio（标准输入/输出），带 JSON-RPC 2.0 消息格式
- **发现**：通过 MCP 能力协商的动态工具模式暴露
- **执行**：带结构化结果返回的同步工具执行
- **错误处理**：基于 anyhow 的错误传播映射到 MCP 错误码

**集成模式：**
AI 助手（例如 Claude Desktop、IDE 代理）通过 JSON-RPC 通信：
```json
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "store_memory",
    "arguments": {
      "content": "User prefers concise technical documentation",
      "thread_id": "session-xyz",
      "role": "user"
    }
  },
  "id": 1
}
```

---

## 4. 核心工作流

### 4.1 记忆存储请求流程

**触发：** 用户通过任何接口（CLI、API 或 MCP）提交记忆

**序列：**
1. **接口接收**
   - CLI：clap 解析参数并调用命令处理器
   - REST：Axum 路由器根据路径/方法调度到处理器
   - MCP：RMCP 框架路由到工具实现

2. **请求验证**
   - 模式验证（REST/MCP 的 JSON Schema、CLI 的类型检查）
   - 授权检查（通过 URI 范围的租户隔离）
   - 内容清理

3. **核心领域委托**
   - 接口构造领域对象（Memory、Session 等）
   - 通过 Arc 共享状态调用 MemoryOperations 方法
   - 如配置了，async await 用于嵌入生成

4. **持久化协调**
   - 并行执行路径：
     - 向量存储：嵌入 → Qdrant 向量数据库
     - 文件系统：内容 → 通过 cortex:// URI 方案的 Markdown 文件

5. **响应格式化**
   - CLI：带颜色编码的终端格式化输出
   - REST：带 URI 和 ID 的 JSON 响应
   - MCP：带成功确认的工具结果结构

### 4.2 语义搜索流程

**触发：** 通过 cortex-mem search 或 POST /api/v2/search 提交搜索查询

**处理管道：**
1. **查询接收** → 解析过滤器（范围、类型、日期范围、重要性阈值）
2. **向量化** → 嵌入客户端将查询文本转换为向量表示
3. **相似性搜索** → 向量搜索引擎使用 HNSW 算法查询 Qdrant
4. **元数据过滤** → 数据库级别按维度、类别、租户过滤
5. **内容检索** → 从文件系统为 top-K 结果获取完整记忆内容
6. **评分和排名** → 计算相关性评分并应用阈值过滤
7. **响应组装** → 带片段和元数据的排名结果返回给调用者

### 4.3 会话生命周期流程

**触发：** 通过 cortex-mem session 或 /api/v2/sessions 创建会话或追加消息

**状态转换：**
```
创建 → 活跃 → [索引] → [提取] → 关闭
```

1. **创建**：SessionManager 使用元数据初始化线程上下文
2. **消息累积**：时间线追加带角色/时间戳的消息；持久化到 markdown
3. **自动索引**（异步）：AutoIndexer 将消息排队等待向量数据库插入
4. **自动提取**（条件）：会话关闭时，LLM 分析时间线以提取结构化记忆（事实、偏好、实体）
5. **终止**：元数据最终化，触发可选记忆提取

---

## 5. 集成模式

### 5.1 共享状态架构

所有三个接口使用**共享状态模式**用于对核心服务的线程安全访问：

```rust
// 跨异步处理器的线程安全共享
pub type SharedState = Arc<AppState>;

// 在 Axum 处理器中
pub async fn search_handler(
    State(state): State<SharedState>,
    Json(payload): Json<SearchRequest>,
) -> Result<Json<SearchResults>, AppError> {
    state.memory_ops.vector_search(payload.query).await
}
```

**好处：**
- Qdrant 和 LLM 客户端的一致连接池
- 跨所有接口的配置单例模式
- 加载模型和缓存的内存高效共享

### 5.2 配置收敛

所有接口遵循相同的初始化序列：

1. **CLI/环境解析**：命令行参数或环境变量
2. **TOML 加载**：来自 config.toml 的配置（可通过 --config 配置路径）
3. **客户端初始化**：可选 LLM、嵌入和向量存储客户端
4. **MemoryOperations 设置**：核心门面用所有依赖初始化
5. **服务启动**：绑定到传输（MCP 的 stdio、REST 的 TCP、CLI 的进程退出）

**配置部分：**
- [llm]：提供商 URL、API 密钥、模型选择
- [qdrant]：向量数据库连接字符串
- [embedding]：嵌入服务配置、维度设置（默认 1536）
- [cortex]：数据目录路径、租户默认值

### 5.3 错误处理策略

| 接口 | 错误类型 | 用户呈现 |
|-----------|-----------|-------------------|
| CLI | anyhow::Error | 带上下文链的彩色 stderr 输出，非零退出码 |
| REST | AppError（自定义枚举） | HTTP 状态码 + JSON {"error": "..."} 体 |
| MCP | rmcp::Error | 带错误码的 JSON-RPC 错误对象 |

**常见错误类别：**
- **400 Bad Request**：无效 URI 格式、缺少必需字段
- **404 Not Found**：记忆 URI 不存在、会话未找到
- **503 Service Unavailable**：LLM/Qdrant 连接失败（带优雅降级）
- **500 Internal Error**：意外的领域失败

---

## 6. 部署模型

### 6.1 独立开发者模式
```
[cortex-mem-cli] ↔ [本地文件系统 + Qdrant]
```
- 直接文件系统访问
- 本地 Qdrant 实例或嵌入式模式
- 无网络暴露

### 6.2 客户端-服务器架构
```
[cortex-mem-cli] ─┐
                   ├─→ [cortex-mem-service] ↔ [Qdrant 集群 + 共享 FS]
[Web 仪表板] ──┘         │
                             ↓
                       [cortex-mem-insights]
```
- 带 REST API 的集中式服务
- 通过租户 ID 头的多租户隔离
- Web 仪表板消费 REST API

### 6.3 AI 代理集成模式
```
[Claude Desktop / IDE 代理] ↔ [cortex-mem-mcp] ↔ [cortex-mem-core] ↔ [存储]
```
- MCP 服务器作为 AI 助手子进程运行
- stdio 传输用于本地集成
- 沙箱化文件系统访问

---

## 7. 安全注意事项

### 7.1 传输安全
- **REST API**：生产推荐 TLS 终止（通过反向代理）
- **MCP**：stdio 传输本质上本地；无网络暴露
- **CLI**：仅本地进程

### 7.2 数据隔离
- **基于 URI 的作用域**：所有请求根据租户范围（cortex://{dimension}/{tenant}/...）验证
- **路径遍历保护**：URI 解析器验证路径组件以防止目录逃逸
- **多租户**：所有操作需要租户 ID；跨租户访问在领域层阻止

### 7.3 输入验证
- REST/MCP JSON 有效负载的严格模式验证
- 内容长度限制以防止内存耗尽
- URI 方案白名单（仅允许 cortex://）

---

## 8. 性能特性

### 8.1 并发
- **Async/Await**：Tokio 运行时高效处理并发请求
- **嵌入批处理**：CLI 和 REST 支持批量操作用于批量索引
- **连接池**：到 Qdrant 和 LLM 服务的持久连接

### 8.2 缓存层
- **层缓存**：生成的 L0/L1 摘要缓存在文件系统以避免 LLM 重新生成成本
- **向量缓存**：Qdrant HNSW 索引提供亚 100ms 相似性搜索
- **配置**：启动时加载一次；不支持热重载（需要重启）

### 8.3 资源限制
- **请求超时**：REST API 用于长时间搜索的可配置超时
- **有效负载限制**：Axum 默认体限制（可配置）
- **背压**：基于异步通道的处理防止批量操作期间的内存溢出

---

## 9. 扩展指南

### 9.1 添加新 CLI 命令
1. 在 src/commands/{command}.rs 创建模块
2. 为参数实现 clap::Parser 派生结构体
3. 在主 CLI 枚举中添加带 #[command(subcommand)] 的变体
4. 调度到 MemoryOperations 方法
5. 实现彩色输出格式化

### 9.2 添加 REST 端点
1. 在 models.rs 中定义请求/响应模型
2. 在适当的 handlers/ 模块中实现处理器函数
3. 在对应的 routes/ 模块中添加带方法和路径的路由
4. 如果需要新依赖则更新 AppState
5. 如果端点从浏览器访问则添加 CORS 配置

### 9.3 添加 MCP 工具
1. 用 #[tool] 属性在服务结构体中添加方法
2. 使用可序列化结构体定义参数
3. 实现委托给 MemoryOperations 的业务逻辑
4. 如果引入新工具类别则更新工具路由器
5. 记录供 AI 助手使用的工具模式

---

## 10. 故障排除

### 10.1 常见集成问题

**CLI："配置文件未找到"**
- 确保 config.toml 存在于默认位置（~/.config/cortex-mem/）或通过 -c 指定

**REST："连接拒绝"到 Qdrant**
- 验证 Qdrant 服务运行且 URL 在配置中正确
- 检查防火墙规则端口 6333（默认 Qdrant HTTP）

**MCP：AI 助手"未找到工具"**
- 验证 MCP 服务器正确启动（stdio 传输活动）
- 检查工具名称完全匹配（区分大小写）
- 确保 JSON-RPC 消息格式合规

### 10.2 调试模式
所有接口支持通过以下方式详细日志：
- CLI：-v, --verbose 标志
- REST：RUST_LOG=debug 环境变量
- MCP：stderr 日志（可在 AI 助手日志中查看）

---

## 附录 A：协议规格

### A.1 URI 方案参考
所有接口使用 cortex:// URI 方案进行资源寻址：
```
cortex://{dimension}/{tenant}/{category}/{resource_id}

示例：
cortex://user/acme-corp/memories/uuid-123
cortex://session/thread-abc/messages/msg-456
cortex://agent/bot-1/profiles/default
```

### A.2 JSON 模式示例

**搜索请求（REST）：**
```json
{
  "query": "machine learning preferences",
  "limit": 10,
  "min_score": 0.75,
  "filters": {
    "dimension": "user",
    "categories": ["preferences", "facts"],
    "date_after": "2024-01-01"
  }
}
```

**MCP 工具结果：**
```json
{
  "content": [
    {
      "type": "text",
      "text": "Memory stored successfully at cortex://user/default/memories/uuid-789"
    }
  ],
  "isError": false
}
```

---

**文档控制**  
**作者：** 技术架构团队  
**审稿人：** 系统工程、DevOps  
**分类：** 技术实施指南  
**相关文档：** 核心领域架构、向量搜索领域规格、部署指南
